import {sym_sampi, as_source_id, make_reply_id} from './base.jsy'

export default msg_source_api
export function msg_source_api(shared) ::
  const { op_unpack, from_api, anon_api } = shared

  return shared.source_api = (src_id, pi_msgs) => ::

    const [from_route, from_target] = as_source_id(src_id)
    if null == from_route || null == from_target ::
      throw new Error @ 'Valid target and route required'

    const mctx = pi_msgs.createMsgContext()

    const source = @{} _recv_pkt_, _send_pkt_: shared._send_pkt_
      toJSON() :: return @{} [sym_sampi]: `${from_route} ${from_target}`

      anon(id) :: return anon_api @ id, null, source
      to(id) :: return from_src @ id, null

      reply_anon(id, token) ::
        return anon_api @ null, make_reply_id(id, token), source
      reply(id, token) ::
        return from_src @ null, make_reply_id(id, token)

    const from_src = from_api @:
      from_route, from_target, mctx, source

    const pkt_api = @{}
      anon() :: return anon_api @ null, this, source
      reply() :: return from_src @ null, this
      resolve(ans) ::
        const {msgid} = this
        return msgid ? mctx.on_resolve(msgid, ans) : ans

    return source

    function _recv_pkt_(pkt) ::
      const op = op_unpack @ pkt, {__proto__: pkt_api}
      if pkt.is_pkt_split ::
        return mctx.on_split_pkt(pkt, op)
      else return pkt

