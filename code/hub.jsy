import FabricRouter_Base from './router.jsy'
import TargetRouter_Base from './targets.jsy'
import P2PRouter_Base from './p2p.jsy'

import {applyPlugins} from './utils.jsy'

export class FabricHub ::
  static create(...args) :: return new this(...args)

  constructor(options) ::
    if null == options :: options = {}
    else if 'string' === typeof options ::
      options = @{} id_route: options

    Object.defineProperties @ this, @{}
      options: {value: options}

    applyPlugins @ 'pre', this.pluginList, this

    const router = this._init_fabricRouter()
    const dispatch = router.dispatch

    const p2p = this._initHubP2PRoute(router)
    const local = this._initHubLocalRoute(options.id_route, router, p2p)

    const channel = this._bindSendLocal(dispatch)
    Object.defineProperties @ this, @{}
      router: @{} value: router
      dispatch: @{} value: dispatch
      channel: @{} value: channel
      send: @{} value: channel.send

      p2p: @{} value: p2p
      local: @{} value: local

      _connectByProtocol: @{} value: {}

    applyPlugins @ null, this.pluginList, this
    applyPlugins @ 'post', this.pluginList, this
    return this


  _init_fabricRouter() ::
    const klass = this.constructor
    return new klass.FabricRouter()

  _initHubP2PRoute(router) ::
    return this.createP2PRoute(router)

  createP2PRoute(router) ::
    const klass = this.constructor
    return new klass.P2PRouter @ router || this.router

  _initHubLocalRoute(id_route, router, p2p) ::
    const local = this.createLocalRoute(id_route, router)
    p2p.publishRoute(local)
    return local

  createLocalRoute(id_route, router) ::
    if null == id_route :: id_route = this.newRouteId()
    const klass = this.constructor
    return new klass.TargetRouter @
      id_route, router || this.router

  newRouteId() ::
    const id = this.data_utils.random_base64(5).slice(0, 6)
    const prefix = this.options.id_prefix
    return undefined === prefix ? id : prefix+id

  /* data_utils is provided by router plugins

  data_utils = @{}
    parse_url(str) ::
    random(n, asBase64) ::
    random_base64(n, asBase64) ::
    pack_base64(data) ::
    unpack_base64(str_b64) ::
    decode_utf8(u8) ::
    encode_utf8(str) ::

  */

  newLocalRoute(privateRoute, id_route) ::
    const route = this.createLocalRoute(id_route, this.router)
    if ! privateRoute ::
      this.p2p.publishRoute(route)
    return route


  connect(conn_url) ::
    if 'string' === typeof conn_url ::
      conn_url = this.data_utils.parse_url(conn_url)
    else if ! conn_url.protocol ::
      conn_url = this.data_utils.parse_url(conn_url.asURL())

    const connect = this._connectByProtocol[conn_url.protocol]
    if ! connect ::
      throw new Error @ `Connection protocol "${conn_url.protocol}" not registered`
    return connect(conn_url)

  registerProtocols(protocolList, cb_connect) ::
    if 'function' !== typeof cb_connect ::
      throw new TypeError @ `Expected 'cb_connect' function`
    for const protocol of protocolList ::
      this._connectByProtocol[protocol] = cb_connect
    return this


  _bindSendLocal(dispatch) ::
    const {_fromObjPacket, _hub_channel_} = this
    return Object.create @ _hub_channel_, @{} send: {value: hub_send}

    function hub_send(obj) ::
      const pkt = _fromObjPacket(obj)
      return dispatch @ pkt, _hub_channel_
  _fromObjPacket(obj) :: return obj // plugin (pkt) responsiblity


  livePlugin(...livePluginList) ::
    return this.livePlugins(...livePluginList)
  livePlugins(...livePluginList) ::
    livePluginList = livePluginList
      .sort @ (a, b) => (0 | a.order) - (0 | b.order)

    applyPlugins @ 'live', livePluginList, this
    applyPlugins @ null, livePluginList, this
    applyPlugins @ 'post', livePluginList, this
    return this

  static plugin(...pluginFunctions) ::
    return this.plugins(...pluginFunctions)
  static plugins(...pluginFunctions) ::
    const pluginList = Object.freeze @
      this.prototype.pluginList
        .concat @ pluginFunctions
        .sort @ (a, b) => (0 | a.order) - (0 | b.order)

    class FabricHub extends this ::
    Object.defineProperties @ FabricHub.prototype, @{}
      pluginList: @{} value: pluginList

    class FabricRouter extends this.FabricRouter ::
    class TargetRouter extends this.TargetRouter ::
    class P2PRouter extends this.P2PRouter ::
    Object.assign @ FabricHub, @{}
      FabricRouter, TargetRouter, P2PRouter

    applyPlugins @ 'subclass', pluginList, FabricHub
    return FabricHub


const _hub_channel_ = @{}
  is_local: true
  undeliverable(pkt, mode) ::
    const {id_route, id_target} = pkt
    console.warn @ '~~ undeliverable «hub»', @{}
      mode, id_route, id_target

Object.defineProperties @ FabricHub.prototype, @{}
  is_fabric_hub: @{} value: true
  pluginList: @{} value: Object.freeze([])
  _hub_channel_: @{} value: Object.create(_hub_channel_)

Object.assign @ FabricHub, @{}
  FabricRouter: FabricRouter_Base
  TargetRouter: TargetRouter_Base
  P2PRouter: P2PRouter_Base

export default FabricHub
