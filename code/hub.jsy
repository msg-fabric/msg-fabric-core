import {URL} from 'url'
import {packetStreamParser} from './parser'
import {MessageRouter} from './router'
import {MessageChannel} from './channel'

export class MessageHub ::
  constructor() ::
    applyPlugins @ this, 'pre', this.pluginList

    const router = this._init_router()
    const _packetStream = this._init_packetStreamParser()
    const _api_channel = this._init_channelAPI(router, _packetStream)
    const _api_internal = this._init_internalAPI(router, _packetStream)
    Object.defineProperties @ this, @{}
      router: @{} value: router
      _packetStream: @{} value: _packetStream
      _api_channel: @{} value: _api_channel
      _api_internal: @{} value: _api_internal

    applyPlugins @ this, null, this.pluginList
    return this

  _init_router() ::
    const id_self = 0 | Math.random() * 0x7fffffff
    console.log @ "DOH", id_self
    return new MessageRouter(id_self)

  _init_packetStreamParser() ::
    return packetStreamParser()
  _init_channelAPI(router, packetStream) ::
    return MessageChannel.asChannelAPI @
      this, router, packetStream
  _init_internalAPI(router, packetStream) ::
    return MessageChannel.asInternalAPI @
      this, router, packetStream


  static plugin(...pluginFunctions) ::
    const pluginList = [].concat @
      this.prototype.pluginList || []
      pluginFunctions

    const BaseHub = this._BaseHub_ || this
    class MessageHub_PI extends BaseHub ::
    Object.defineProperties @ MessageHub_PI.prototype, @:
      pluginList: @{} value: Object.freeze @ pluginList
    Object.defineProperties @ MessageHub_PI, @:
      _BaseHub_: @{} value: BaseHub

    return applyPlugins @ MessageHub_PI, 'subclass', pluginList

  id_router_self() ::
    return this._packetStream.packId @
      this.router.id_self

  connect_self() ::
    return this._api_internal.clone()

  connect(conn_url) ::
    if null == conn_url ::
      return this.connect_self()

    if 'string' === typeof conn_url ::
      conn_url = new URL(conn_url)

    const connect = this._connectByProtocol[conn_url.protocol]
    if ! connect ::
      throw new Error @ `Connection protocol "${conn_url.protocol}" not registered for "${conn_url.toString()}"`

    return connect(conn_url)

  registerConnectionProtocol(protocol, cb_connect) ::
    if 'function' !== typeof cb_connect ::
      throw new TypeError @ `Expected 'cb_connect' function`
    const byProtocol = Object.assign @ {}, this._connectByProtocol
    byProtocol[protocol] = cb_connect
    return Object.defineProperty @ this, '_connectByProtocol',
      @: value: byProtocol, configurable: true

export default MessageHub

export function applyPlugins(target, key, pluginList) ::
  if ! key :: key = null
  for let plugin of pluginList ::
    if null !== key :: plugin = plugin[key]
    if 'function' === typeof plugin ::
      plugin(target)
  return target
