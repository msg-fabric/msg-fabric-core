import { random_base64, parse_url, data_utils } from './data_utils.jsy'

import { json_codec } from './channel.jsy'
import FabricRouter_Base from './router.jsy'
import TargetRouter_Base from './targets.jsy'
import P2PRouter_Base from './p2p.jsy'

import { applyPlugins, cmpPlugins } from './utils.jsy'

export class FabricHub ::
  static create(...args) :: return new this(...args)

  constructor(options) ::
    const self = Object.create(this)

    if null == options :: options = {}
    else if 'string' === typeof options ::
      options = @{} id_route: options
    this.options = options


    applyPlugins @ 'pre', this._plugins_, self

    const router = self._initFabricRouter()
    const p2p = self._initHubP2PRoute(router)
    const local = self._initHubLocalRoute(options.id_route, router, p2p)

    const channel = router.local_channel()
    Object.assign @ this, @{}
      router, p2p, local,
      channel, send: channel.send
      _url_protos: {}

    applyPlugins @ null, this._plugins_, self
    applyPlugins @ 'post', this._plugins_, self
    return self

  _initFabricRouter() ::
    return new this.constructor.FabricRouter()

  _initHubP2PRoute(router) ::
    return this.createP2PRoute(router)

  createP2PRoute(router) ::
    return new this.constructor.P2PRouter @ router || this.router, this

  _initHubLocalRoute(id_route, router, p2p) ::
    const local = this.createLocalRoute(id_route, router)
    p2p.publishRoute(local)
    return local

  createLocalRoute(id_route, router) ::
    if null == id_route :: id_route = this.newRouteId()
    return new this.constructor.TargetRouter @
      id_route, router || this.router, this

  newRouteId() ::
    const id = random_base64(5).slice(0, 6)
    const prefix = this.options.id_prefix
    return undefined === prefix ? id : prefix+id

  newLocalRoute(privateRoute, id_route) ::
    const route = this.createLocalRoute(id_route, this.router)
    if ! privateRoute ::
      this.p2p.publishRoute(route)
    return route


  connect(conn_url) ::
    if ! conn_url.protocol ::
      conn_url = parse_url @
        conn_url.asURL ? conn_url.asURL() : ''+conn_url

    const connect = this._url_protos[conn_url.protocol]
    if ! connect ::
      throw new Error @ `Connection protocol "${conn_url.protocol}" not found`
    return connect(conn_url)

  registerProtocols(protocolList, cb_connect) ::
    if 'function' !== typeof cb_connect ::
      throw new TypeError()
    for const protocol of protocolList ::
      this._url_protos[protocol] = cb_connect
    return this


  // --- plugin support ---

  livePlugin(... _plugins_) ::
    _plugins_.sort(cmpPlugins)

    applyPlugins @ 'live', _plugins_, this
    applyPlugins @ null, _plugins_, this
    applyPlugins @ 'post', _plugins_, this
    return this

  static plugin(... _plugins_) ::
    _plugins_ = Object.freeze @
      this._plugins_
        .concat @ _plugins_
        .sort @ cmpPlugins

    const inst_plugins = _plugins_.slice()

    class FabricRouter extends this.FabricRouter ::
    class TargetRouter extends this.TargetRouter ::
    class P2PRouter extends this.P2PRouter ::

    class FabricHub extends this ::
    FabricHub.prototype._plugins_ = inst_plugins

    Object.assign @ FabricHub, @{} _plugins_,
      FabricRouter, TargetRouter, P2PRouter

    applyPlugins @ 'subclass', _plugins_, FabricHub, inst_plugins
    inst_plugins.sort @ cmpPlugins
    return FabricHub


Object.assign @ FabricHub.prototype, @{}
  _plugins_: Object.freeze([])
  is_fabric_hub: true
  data_utils
  json_codec
  stream_codec: json_codec

Object.assign @ FabricHub, @{}
  _plugins_: Object.freeze([])
  FabricRouter: FabricRouter_Base
  TargetRouter: TargetRouter_Base
  P2PRouter: P2PRouter_Base

export default FabricHub
