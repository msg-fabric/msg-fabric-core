import {createECDH, createHmac} from 'crypto'

import {packMessage} from './parser'
import {packetStreamParser} from './parser'
import * as channel_setup from './channel_setup'

export class PacketMessageHub ::
  constructor() ::
    const router = new MessageRouter()
    const id_self = router.id_self

    Object.defineProperties @ this, @{}
      id_self: @{} value: id_self
      router: @{} value: router
      _packetStream: @{} value: packetStreamParser()
      _msg_hello: @{} value: channel_setup.pack_hello @ router.ec_pub_id

  on_connect_peer(stream, sendMsgRaw) ::
    if 'function' !== typeof sendMsgRaw ::
      throw new TypeError @ `Expected 'sendMsgRaw' to be a function`

    sendMsgRaw @ this._msg_hello 
    const dispatch = this.router.dispatch
    return connectPacketStream @
      this._packetStream.clone(), stream
      msgList => dispatch(msgList, sendMsgRaw)


class MessageRouter ::
  constructor() ::
    ::
      const ec_priv_id = createECDH('prime256v1')
      var ec_pub_id = ec_priv_id.generateKeys(null, 'compressed')
      var ec_id_hmac = function (ec_pub_other, expected) ::
        const secret = ec_priv_id.computeSecret(ec_pub_other)
        return createHmac('sha256', secret)
          .update @ expected ? ec_pub_other : ec_pub_id
          .digest()

    const id_self = ec_pub_id.readUInt32LE(8) // read id from offset 8 to 12

    // bind dispatch as a closure over id_self
    const dispatch = (msgList, sendMsgRaw) => ::
      for const msg of msgList ::
        const id_router = msg.id_router

        if id_self === id_router ::
          const handler = this.dispSelfByType[msg.type]
          if undefined === handler ::
            this.dnu_dispatch_self(msg)
          else handler @ this, msg

        else if 0 !== id_router ::
          const relayMsgRaw = this.routes.get(id_router)
          if undefined === relayMsgRaw ::
            this.dispatch_unknown_route(id_router, msg)
          else if false === relayMsgRaw(msg) ::
            this.routes.delete(id_router)

        else :: // 0 === id_router // control message
          const handler = this.dispControlByType[msg.type]
          if undefined === handler ::
            this.dnu_dispatch_control(msg, sendMsgRaw)
          else handler @ this, msg, sendMsgRaw

    return Object.defineProperties @ this, @:
      id_self: @: value: id_self
      ec_pub_id: @: value: ec_pub_id
      dispatch: @: value: dispatch
      ec_id_hmac: @: value: ec_id_hmac


  dnu_dispatch_self(msg) ::
    console.warn @ "dnu_dispatch_self", msg.type, msg

  dispatch_unknown_route(id_router, msg) ::
    console.log @ "TODO: implement dispatch_unknown_route", msg

  routes = new Map()
  registerRoute(id_router, sendMsgRaw) ::
    console.log @ 'add peer:', id_router, '<==>', this.id_self
    this.routes.set @ id_router, sendMsgRaw
  unregisterRoute(id_router) ::
    return this.routes.delete @ id_router
  imposterRoute(id_router) ::

  dispControlByType = Object.create @ this.dispControlByType
  dnu_dispatch_control(msg, sendMsgRaw) ::
    console.warn @ "dnu_dispatch_control", msg.type, msg

MessageRouter.prototype.dispControlByType = Object.assign @ {}
  channel_setup.dispControlByType


export function connectPacketStream(pktParser, stream, on_recv_messages) ::
  return new Promise @ (resolve, reject) => ::
    stream.on @ 'error', shutdown
    stream.on @ 'close', shutdown
    stream.on @ 'data', data => ::
      try ::
        var msgList = pktParser.feed @ data
        if 0 < msgList.length ::
          on_recv_messages(msgList)
      catch err ::
        return shutdown(err)


    function shutdown(err) ::
      if undefined === stream :: return
      pktParser = undefined
      stream.end()
      stream = undefined

      err ? reject(err) : resolve()

