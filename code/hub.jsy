import { random_base64, parse_url, data_utils } from './data_utils.jsy'

import { json_codec } from './channel.jsy'
import { basic_p2p } from './p2p_core.jsy'
import FabricRouter_Base from './router.jsy'
import TargetRouter_Base from './targets.jsy'

import { applyPlugins, cmpPlugins } from './utils.jsy'

export class FabricHub ::
  static create(...args) :: return new this(...args)

  constructor(options) ::
    const self = Object.create(this)

    if null == options :: options = {}
    else if 'object' !== typeof options ::
      options = @{} id_route: options
    this.options = options


    applyPlugins @ 'pre', this._plugins_, self

    const router = self._initHubRouter()
    const channel = router.local_channel()
    Object.assign @ this, @{}
      router, channel, send: channel.send
      _url_protos: {}

    this.local = false === options.id_route ? null
      : self._initLocal(options.id_route)

    applyPlugins @ null, this._plugins_, self
    applyPlugins @ 'post', this._plugins_, self
    return self

  _initHubRouter() ::
    return new this.constructor.FabricRouter()
  _initLocal(id_route) ::
    return this.createLocalRoute(id_route)

  createLocalRoute(id_route, is_private) ::
    if null == id_route :: id_route = this.newRouteId()
    const local = new this.constructor.TargetRouter @
      id_route, this.router, this

    if ! is_private :: this.router.publishRoute(local)
    return local

  newRouteId() ::
    const id = random_base64(5).slice(0, 6)
    const prefix = this.options.id_prefix
    return undefined === prefix ? id : prefix+id



  connect(conn_url) ::
    if ! conn_url.protocol ::
      conn_url = parse_url @
        conn_url.asURL ? conn_url.asURL() : ''+conn_url

    const connect = this._url_protos[conn_url.protocol]
    if ! connect ::
      throw new Error @ `Connection protocol "${conn_url.protocol}" not found`
    return connect(conn_url)

  registerProtocols(protocolList, cb_connect) ::
    if 'function' !== typeof cb_connect ::
      throw new TypeError()
    for const protocol of protocolList ::
      this._url_protos[protocol] = cb_connect
    return this


  // --- plugin support ---

  livePlugin(... _plugins_) ::
    _plugins_.sort(cmpPlugins)

    applyPlugins @ 'live', _plugins_, this
    applyPlugins @ null, _plugins_, this
    applyPlugins @ 'post', _plugins_, this
    return this

  static plugin(... _plugins_) ::
    _plugins_ = Object.freeze @
      this._plugins_
        .concat @ _plugins_
        .sort @ cmpPlugins

    const inst_plugins = _plugins_.slice()

    class FabricRouter extends this.FabricRouter ::
    class TargetRouter extends this.TargetRouter ::

    class FabricHub extends this ::
    FabricHub.prototype._plugins_ = inst_plugins

    Object.assign @ FabricHub, @{} _plugins_,
      FabricRouter, TargetRouter

    applyPlugins @ 'subclass', _plugins_, FabricHub, inst_plugins
    inst_plugins.sort @ cmpPlugins
    return FabricHub


Object.assign @ FabricHub.prototype, @{}
  is_fabric_hub: true
  _plugins_: Object.freeze([])
  data_utils,
  json_codec, stream_codec: json_codec
  basic_p2p, p2p: basic_p2p

Object.assign @ FabricHub, @{}
  _plugins_: Object.freeze([])
  FabricRouter: FabricRouter_Base
  TargetRouter: TargetRouter_Base

export default FabricHub
