import {Router} from './router.jsy'
import {Channel} from './channel.jsy'

export class FabricHub ::
  constructor() ::
    applyPlugins @ 'pre', this.pluginList, this

    const packetParser = this.packetParser
    if null==packetParser || ! packetParser.isPacketParser() ::
      throw new TypeError @ `Invalid hub.packetParser`

    const router = this._init_router()
    const _api_channel = this._init_channelAPI(packetParser)
    const _api_internal = this._init_internalAPI(packetParser)
    router.initDispatch()
    _api_internal.bindInternalChannel @ router.dispatch

    Object.defineProperties @ this, @{}
      router: @{} value: router
      packetParser: @{} value: packetParser
      _api_channel: @{} value: _api_channel
      _api_internal: @{} value: _api_internal

    applyPlugins @ null, this.pluginList, this
    applyPlugins @ 'post', this.pluginList, this
    return this

  _init_router() :: throw new Error @ `Plugin responsiblity`

  _init_channelAPI(packetParser) ::
    return Channel.asChannelAPI @ this, packetParser
  _init_internalAPI(packetParser) ::
    return Channel.asInternalAPI @ this, packetParser


  static plugin(...pluginFunctions) ::
    return this.plugins(...pluginFunctions)
  static plugins(...pluginFunctions) ::
    const pluginList = [].concat @
      this.prototype.pluginList || []
      pluginFunctions

    pluginList.sort @ (a, b) => (0 | a.order) - (0 | b.order)

    const BaseHub = this._BaseHub_ || this
    class FabricHub_PI extends BaseHub ::
    Object.defineProperties @ FabricHub_PI.prototype, @:
      pluginList: @{} value: Object.freeze @ pluginList
    Object.defineProperties @ FabricHub_PI, @:
      _BaseHub_: @{} value: BaseHub

    applyPlugins @ 'subclass', pluginList, FabricHub_PI, @: Router, Channel
    return FabricHub_PI


  get id_self() ::
    return this.router.id_self
  id_router_self() ::
    return this.packetParser.packId @
      this.router.id_self
  connect_self() ::
    return this._api_internal.clone()
  bindRouteDispatch(channel) ::
    if null == channel :: channel = this.connect_self()
    return id_router => ::
      let route, disco = this.router.resolveRoute(id_router)
      return async pkt => ::
        if undefined === route ::
          route = disco = await disco
        return route @ pkt, channel

  connect(conn_url) ::
    if null == conn_url ::
      return this.connect_self()

    if 'string' === typeof conn_url ::
      conn_url = this._parseConnectURL(conn_url)

    const connect = this._connectByProtocol[conn_url.protocol]
    if ! connect ::
      throw new Error @ `Connection protocol "${conn_url.protocol}" not registered for "${conn_url.toString()}"`

    return connect(conn_url)

  registerConnectionProtocol(protocol, cb_connect) ::
    if 'function' !== typeof cb_connect ::
      throw new TypeError @ `Expected 'cb_connect' function`
    const byProtocol = Object.assign @ {}, this._connectByProtocol
    byProtocol[protocol] = cb_connect
    return Object.defineProperty @ this, '_connectByProtocol',
      @: value: byProtocol, configurable: true

  _parseConnectURL(conn_url) ::
    return new URL(conn_url)

export default FabricHub

export function applyPlugins(key, pluginList, ...args) ::
  if ! key :: key = null
  for let plugin of pluginList ::
    if null !== key :: plugin = plugin[key]
    if 'function' === typeof plugin ::
      plugin(...args)
