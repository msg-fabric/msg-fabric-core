import {URL} from 'url'
import {packetStreamParser} from './parser'
import {MessageRouter} from './router'
import {MessageChannel} from './channel'

export class MessageHub ::
  constructor() ::
    const router = this._init_router()
    const _packetStream = this._init_packetStreamParser()
    const _api_channel = this._init_channelAPI(router, _packetStream)
    const _api_internal = this._init_internalAPI(router, _packetStream)
    Object.defineProperties @ this, @{}
      router: @{} value: router
      _packetStream: @{} value: _packetStream
      _api_channel: @{} value: _api_channel
      _api_internal: @{} value: _api_internal

    if this.pluginList ::
      this.plugin @ ... this.pluginList

  _init_router() ::
    return new MessageRouter()

  _init_packetStreamParser() ::
    return packetStreamParser()
  _init_channelAPI(router, packetStream) ::
    return Object.defineProperties @
      new MessageChannel(), @:
        pack: @: value: packetStream.packMessage
        hub: @: value: this
        router: @: value: router
  _init_internalAPI(router, packetStream) ::
    const api_internal = Object.defineProperties @
      new MessageChannel(), @:
        pack: @: value: packetStream.packMessageObj
        hub: @: value: this
        router: @: value: router

    bindDispatchMsgRaw(api_internal)
    return api_internal

  plugin(...pluginFunctions) ::
    for const plugin of pluginFunctions ::
      plugin(this)
    return this

  static plugin(...pluginFunctions) ::
    const pluginList = [].concat @
      this.prototype.pluginList || []
      pluginFunctions

    const BaseHub = this._BaseHub_ || MessageHub
    class PacketMessageHub_PI extends BaseHub ::
    Object.defineProperties @ PacketMessageHub_PI.prototype, @:
      pluginList: @{} value: Object.freeze @ pluginList
    Object.defineProperties @ PacketMessageHub_PI, @:
      _BaseHub_: @{} value: BaseHub
    return PacketMessageHub_PI


  connect_self() ::
    return Object.create @ this._api_internal

  _connectByProtocol = new Map() // provided by pluginsâ€¦
  connect(conn_url) ::
    if null == conn_url ::
      return this.connect_self()

    if 'string' === typeof conn_url ::
      conn_url = new URL(conn_url)

    const connect = this._connectByProtocol.get(conn_url.protocol)
    if connect ::
      return connect(conn_url)
    else throw new Error @ `Connection protocol "${conn_url.protocol}" not registered for "${conn_url.toString()}"`


  on_connect_peer_stream(stream, sendMsgRaw) ::
    this.router.sendRoutingHandshake(sendMsgRaw)

    const dispatch = this.router.dispatch
    sendMsgRaw.shutdown = connectPacketStream @
      this._packetStream.clone(), stream
      msgList => dispatch @ msgList, sendMsgRaw


export function connectPacketStream(pktParser, stream, on_recv_messages) ::
  return new Promise @ (resolve, reject) => ::
    stream.on @ 'error', shutdown
    stream.on @ 'close', shutdown
    stream.on @ 'data', data => ::
      try ::
        var msgList = pktParser.feed @ data
        if 0 < msgList.length ::
          on_recv_messages(msgList)
      catch err ::
        return shutdown(err)

    function shutdown(err) ::
      if undefined === stream :: return
      pktParser = undefined
      stream = undefined

      err ? reject(err) : resolve()


export function bindDispatchMsgRaw(api_internal) ::
  const dispatch = api_internal.router.dispatch
  dispatchMsgRaw.api = Object.defineProperties @ api_internal, @:
    sendRaw: @: value: dispatchMsgRaw
  return dispatchMsgRaw

  function dispatchMsgRaw(msg, asPromise) ::
    dispatch @ [msg], dispatchMsgRaw
    if asPromise :: return Promise.resolve()
