import FabricRouter_Base from './router.jsy'
import TargetRouter_Base from './targets.jsy'
import P2PRouter_Base from './p2p.jsy'

import {applyPlugins} from './utils.jsy'

export class FabricHub ::
  static create(...args) :: return new this(...args)

  constructor(id_local_route) ::
    applyPlugins @ 'pre', this.pluginList, this

    const router = this._init_fabricRouter()
    const p2p = this.createP2PRoute(router)
    const local = this.createLocalRoute(router, id_local_route)
    p2p.publishRoute(local)

    Object.defineProperties @ this, @{}
      dispatch: @{} value: router.dispatch
      router: @{} value: router
      p2p: @{} value: p2p
      local: @{} value: local

      _connectByProtocol: @{} value: {}

    applyPlugins @ null, this.pluginList, this
    applyPlugins @ 'post', this.pluginList, this
    return this


  _init_fabricRouter() ::
    const klass = this.constructor
    return new klass.FabricRouter()

  createP2PRoute(router=this.router) ::
    const klass = this.constructor
    return new klass.P2PRouter @ router

  createLocalRoute(router=this.router, id_route) ::
    if null == id_route :: id_route = this._newRouteId()
    const klass = this.constructor
    return new klass.TargetRouter @
      id_route, router
  //_newRouteId() :: throw new Error @ `subclass responsiblity`

  newLocalRoute(privateRoute, id_route) ::
    const route = this.createLocalRoute(this.router, id_route)
    this.p2p.publishRoute(route)
    return route


  connect(conn_url) ::
    if null == conn_url ::
      return this._api_internal.clone()

    if 'string' === typeof conn_url ::
      conn_url = this._parseConnectURL(conn_url)

    const connect = this._connectByProtocol[conn_url.protocol]
    if ! connect ::
      throw new Error @ `Connection protocol "${conn_url.protocol}" not registered`
    return connect(conn_url)

  _parseConnectURL(conn_url) :: return new URL(conn_url)
  registerConnectionProtocol(protocol, cb_connect) ::
    if 'function' !== typeof cb_connect ::
      throw new TypeError @ `Expected 'cb_connect' function`
    this._connectByProtocol[protocol] = cb_connect
    return this


  send(...objs) ::
    const pktList = objs.map @ this._fromObjPacket
    return this.dispatch @ pktList, this._hub_channel_
  _fromObjPacket(obj) :: return obj // plugin (pkt) responsiblity


  static plugin(...pluginFunctions) ::
    return this.plugins(...pluginFunctions)
  static plugins(...pluginFunctions) ::
    const pluginList = Object.freeze @
      this.prototype.pluginList
        .concat @ pluginFunctions
        .sort @ (a, b) => (0 | a.order) - (0 | b.order)

    class FabricHub_PI extends this ::
    Object.defineProperties @ FabricHub_PI.prototype, @{}
      pluginList: @{} value: pluginList

    class FabricRouter extends this.FabricRouter ::
    class TargetRouter extends this.TargetRouter ::
    class P2PRouter extends this.P2PRouter ::
    Object.assign @ FabricHub_PI, @{}
      FabricRouter, TargetRouter, P2PRouter

    applyPlugins @ 'subclass', pluginList, FabricHub_PI
    return FabricHub_PI


const _hub_channel_ = @{}
  undeliverable(pkt, mode) ::
    const {id_route, id_target} = pkt
    console.warn @ '~~ undeliverable «hub»', @{}
      mode, id_route, id_target

Object.defineProperties @ FabricHub.prototype, @{}
  pluginList: @{} value: Object.freeze([])
  _hub_channel_: @{} value: _hub_channel_

Object.assign @ FabricHub, @{}
  FabricRouter: FabricRouter_Base
  TargetRouter: TargetRouter_Base
  P2PRouter: P2PRouter_Base

export default FabricHub
