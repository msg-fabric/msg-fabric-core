export const dispControlByType = @{}
  [0xf0]: recv_hello
  [0xf1]: recv_olleh
  [0xfe]: recv_pong
  [0xff]: recv_ping



export function send_hello(channel) ::
  const {ec_pub_id} = channel.router
  return channel.packAndSendRaw @:
    id_router: 0, type: 0xf0
    header: ec_pub_id // buffer

function recv_hello(dispatch, msg, channel) ::
  const ec_other_id = msg.sliceHeader()
  const hmac_secret = dispatch.ec_id_hmac
    ? dispatch.ec_id_hmac(ec_other_id) : null
  send_olleh @ channel, hmac_secret



function send_olleh(channel, hmac_secret) ::
  const {ec_pub_id} = channel.router
  return channel.packAndSendRaw @:
    id_router: 0, type: 0xf1
    header: ec_pub_id // buffer
    body: hmac_secret // buffer

function recv_olleh(dispatch, msg, channel) ::
  const ec_pub_id = msg.sliceHeader()
  const id_router = msg.readId(ec_pub_id)

  const hmac_secret = dispatch.ec_id_hmac
    ? dispatch.ec_id_hmac(ec_pub_id, true) : null
  const peer_hmac_claim = msg.sliceBody()
  if hmac_secret && 0 === hmac_secret.compare @ peer_hmac_claim ::
    dispatch.verifiedPeerRoute @ id_router, channel
  else ::
    dispatch.unverifiedPeerRoute @ id_router, channel



export function send_pingpong(channel, pong) ::
  return channel.packAndSendRaw @:
    id_router: 0, type: pong ? 0xfe : 0xff
    body: new Date().toISOString()

function recv_pong(dispatch, msg, channel) ::
  const local = new Date()

  try ::
    const remote = new Date @ msg.sliceBody().toString()
    const delta = remote - local
    channel.ts_pong = @{} delta, remote, local
  catch err ::
    channel.ts_pong = @{} local

function recv_ping(dispatch, msg, channel) ::
  const local = new Date()

  send_pingpong @ channel, true

  try ::
    const remote = new Date @ msg.sliceBody().toString()
    const delta = remote - local
    channel.ts_ping = @{} delta, remote, local
  catch err ::
    channel.ts_ping = @{} local

