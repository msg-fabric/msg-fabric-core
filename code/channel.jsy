import { o_assign, o_create, is_array, p_res, _ref, _unref } from './builtins.jsy'
import { ao_defer_v } from './timeouts.jsy'


export const channel_kinds = @{}
  raw_channel, send_channel, codec_channel, local_channel

export const base_channel = @{}
  channel_id: null

  toJSON() :: throw new Error @ 'Not serializable'
  to_cbor_encode() :: throw new Error @ 'Not serializable'

  undeliverable(pkt, mode) ::
    let {0: id_route, 1: id_target} = pkt
    console.warn @ '~~ undeliverable',
      @{} mode, id_route, id_target

  on_send_error(err) ::
    console.warn @ '~~ channel send error', err

  addRoute(id_route, opt) ::
    return this.router.addPeer @
      id_route, this, opt

  get peerRoute() ::
    let {p2p} = this
    return p2p ? p2p.peerRoute.bind(p2p) : Boolean

  close() :: return false

  async init(channel_id) ::
    if undefined === this.peer_info ::
      this.peer_info = p_res(this.ready)
        .then @=> this.p2p ? this.p2p.hello() : null
      this.peer_info.catch(Boolean) // supress 'unhandled rejection' warnings

    if channel_id ::
      this.channel_id = channel_id
    return await this


const _shapeof = v => 'string' === typeof v ? 's' : 'v'
export function as_send_pkt(args) ::
  if 1 === args.length :: return args[0]
  let k = args.map(_shapeof)
  return as_send_pkt[k] @ ...args

o_assign @ as_send_pkt, @{}
  's,s,v': pkt_3, 's,s,s': pkt_3,
  's,s,v,v': pkt_4, 's,s,s,v': pkt_4, 's,s,v,s': pkt_4, 's,s,s,s': pkt_4,
  'v,v': pkt_o2, 'v,s': pkt_o2,
  'v,v,v': pkt_o3, 'v,v,s': pkt_o3, 'v,s,s': pkt_o3,

function pkt_4(id_route, id_target, meta, body) ::
  return @{} 0:id_route, 1:id_target, meta, body
function pkt_3(id_route, id_target, body) ::
  return @{} 0:id_route, 1:id_target, body
function pkt_o2(addr, body) ::
  if addr :: return o_assign @ {body}, addr
function pkt_o3(addr, meta, body) ::
  if addr :: return o_assign @ {meta, body}, addr


export function raw_channel(p2p, unpack, chan_ex) ::
  let channel = o_assign @ o_create(this._channel_), chan_ex

  if null != p2p ::
    if ! p2p.hello || ! p2p.peerRoute ::
      throw new TypeError

    channel.p2p = p2p.initForChannel(channel)

  let r_disp = this.dispatch
  let recv = unpack
    ? async pkt => r_disp @ await unpack(await pkt), channel
    : async pkt => r_disp @ await pkt, channel

  return @[] recv, channel


export function send_channel(p2p, dispatch) ::
  return this.raw_channel @ p2p, null, @{}
    dispatch
    send: async (...args) =>
      dispatch @ await as_send_pkt @ args
    send_pkt: async pkt =>
      dispatch @ await pkt


export function codec_channel(p2p, dispatch, {encode_pkt, decode_pkt}) ::
  // see plugin/standard/json_codec.jsy for a codec implementation
  return this.raw_channel @ p2p, decode_pkt, @{}
    dispatch: async pkt =>
      dispatch @ await encode_pkt @ pkt
    send: async (...args) =>
      dispatch @ await encode_pkt @ as_send_pkt @ args
    send_pkt: async pkt =>
      dispatch @ await encode_pkt @ pkt



export function local_channel() ::
  let pkt_id=1, map = new Map()

  // use MessageChannel for Structured Clone
  let { port1, port2 } = new MessageChannel()

  let send_pkt = pkt => ::
    let id=pkt_id++, dp=ao_defer_v()
    map.set(id, dp)
    port1.postMessage @# id, pkt
    return dp[0]


  port2.onmessage = evt => ::
    let [id, pkt] = evt.data
    let [p, resolve, reject] = map.get(id)
    map.delete(id)

    try ::
      let res = recv(pkt)
      resolve(res)
    catch err ::
      channel.on_send_error(err)
      reject(err)

  let [recv, channel] = this.raw_channel @ null, null, @{}
    is_local: true, addRoute: null
    dispatch: this.dispatch,
    send: (...args) => send_pkt @ as_send_pkt(args)
    send_pkt
    ref() :: _ref(port2)
    unref() :: _unref(port2)

  _unref(port2)
  return channel

