const o_assign = Object.assign, o_create = Object.create

export const channel_kinds = @{}
  send_channel, codec_channel, local_channel

export const base_channel = @{}
  __proto__: null
  channel_id: null

  toJSON() :: throw new Error @ 'Not serializable'

  undeliverable(pkt, mode) ::
    const {id_route, id_target} = pkt
    console.warn @ '~~ undeliverable',
      @{} mode, id_route, id_target

  on_dispatch_error(pkt, err) ::
    const {id_route, id_target} = pkt
    console.warn @ '~~ channel dispatch error',
      @{} id_route, id_target
      err

  on_send_error(err) ::
    console.warn @ '~~ channel send error', err

  addRoute(id_route, override) ::
    return this.router.addRoute @
      id_route, this.dispatch || this.send, override

  get peerRoute() ::
    const p2p = this.p2p
    return p2p.peerRoute.bind(p2p)

  async init(channel_id) ::
    if undefined === this.peer_info ::
      this.peer_info = Promise.resolve(this.ready)
        .then @=> this.p2p ? this.p2p.hello() : null

    if channel_id ::
      this.channel_id = channel_id
    return await this


const _typeof = v => typeof v
export function as_send_pkt(args) ::
  if 1 === args.length :: return args[0]
  return as_send_pkt[args.map(_typeof)] @ ...args

o_assign @ as_send_pkt, @{}
  'string,string,object'(id_route, id_target, body) ::
    return @{} id_route, id_target, body
  'object,object'(addr, body) ::
    return o_assign @ {body}, addr


function _init_p2p(chan, p2p) ::
  if null != p2p ::
    if ! p2p.hello || ! p2p.peerRoute ::
      throw new TypeError

    chan.p2p = o_create @ p2p, @{}
      channel: @{} value: chan
      router: @{} value: chan.router
  return chan


export function send_channel(p2p, send_ex) ::
  const { dispatch } = this
  const chan = @{}
    __proto__: this._channel_
    dispatch: send_ex, send

  _init_p2p(chan, p2p)
  return @[] recv, chan

  async function send(...args) ::
    const pkt = as_send_pkt(args)
    return await send_ex @ pkt
  async function recv(pkt) ::
    return dispatch @ await pkt, chan


export function codec_channel(p2p, send_ex, codec) ::
  // see plugin/standard/json_codec.jsy for a codec implementation
  const { dispatch } = this
  const chan = @{}
    __proto__: this._channel_
    dispatch: resend, send

  _init_p2p(chan, p2p)
  return @[] recv, chan

  async function send(...args) ::
    const pkt = as_send_pkt(args)
    const pkt_data = await codec.encode @ pkt
    return await send_ex @ pkt_data
  async function resend(pkt) ::
    const pkt_data = await codec.encode @ pkt
    return send_ex @ pkt_data
  async function recv(pkt_data) ::
    const pkt = await codec.decode @ pkt_data
    return dispatch @ await pkt, chan




#IF PLAT_NODEJS
  // use V8's serialize & deserialize for Structured Clone
  const { serialize, deserialize } = require('v8')

  export function local_channel(dispatch) ::
    if ! dispatch :: dispatch = this.dispatch
    const chan = @{}
      __proto__: this._channel_
      send, is_local: true
      addRoute: null,

    return chan

    async function send(...args) ::
      const pkt = as_send_pkt(args)
      return await _send_ex @ serialize @ pkt

    async function _send_ex(pkt) ::
      try ::
        pkt = deserialize @ await pkt
        return dispatch(pkt, chan)
      catch err ::
        chan.on_dispatch_error @ pkt, err

#ELSE
  // use MessageChannel for Structured Clone
  export function local_channel(dispatch) ::
    if ! dispatch :: dispatch = this.dispatch
    const { port1, port2 } = new MessageChannel()
    port2.onmessage = _send_ex

    const map = new Map()
    let q=[], pkt_id=1

    const chan = @{}
      __proto__: this._channel_
      send, is_local: true
      addRoute: null,

    return chan

    function send(...args) ::
      const pkt = as_send_pkt(args)
      return new Promise @ resolve => ::
        const id = q.pop() || pkt_id++
        map.set @ id, resolve
        port1.postMessage @# id, pkt

    function _send_ex(evt) ::
      const [id, pkt] = evt.data
      const resolve = map.get(id)
      map.delete(id)
      q.push(id)

      try ::
        return resolve @ dispatch(pkt, chan)
      catch err ::
        chan.on_dispatch_error @ pkt, err

