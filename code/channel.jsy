import { decode_utf8 } from './data_utils.jsy'

const o_assign = Object.assign

export const channel_kinds = @{}
  send_channel, codec_channel, local_channel

export const base_channel = @{}
  __proto__: null
  channel_id: null

  toJSON() :: throw new Error @ 'Not serializable'

  undeliverable(pkt, mode) ::
    const {id_route, id_target} = pkt
    console.warn @ '~~ undeliverable',
      @{} mode, id_route, id_target

  on_dispatch_error(pkt, err) ::
    const {id_route, id_target} = pkt
    console.warn @ '~~ channel dispatch error',
      @{} id_route, id_target
      err

  on_send_error(err) ::
    console.warn @ '~~ channel send error', err

  addRoute(id_route, override) ::
    return this.router.addRoute @
      id_route, this.dispatch || this.send, override

  //shutdown() ::

async function _post_sent(pkt, p) ::
  if undefined === pkt.on_sent ::
    return p

  const r = await p
  pkt.on_sent(pkt)
  return r



export function send_channel(send_ex) ::
  const { dispatch } = this
  const chan = @{}
    __proto__: this._channel_
    dispatch: send_ex, send

  return @[] recv, chan

  function send(pkt) ::
    return _post_sent @ pkt, send_ex @ pkt
  async function recv(pkt) ::
    return dispatch @ await pkt, chan


export function codec_channel(send_ex, codec) ::
  const { dispatch } = this
  const chan = @{}
    __proto__: this._channel_
    dispatch: resend, send

  return @[] recv, chan

  async function send(pkt) ::
    const pkt_data = await codec.encode @ pkt
    return _post_sent @ pkt, send_ex @ pkt_data
  async function resend(pkt) ::
    const pkt_data = await codec.encode @ pkt
    return send_ex @ pkt_data
  async function recv(pkt_data) ::
    const pkt = await codec.decode @ pkt_data
    return dispatch @ await pkt, chan

export const json_codec = @{}
  __proto__: null
  encode(pkt) ::
    return JSON.stringify(pkt)
  decode(pkt_data) ::
    return JSON.parse @ 
      'string' === typeof pkt_data ? pkt_data
        : decode_utf8 @ pkt_data




#IF PLAT_NODEJS
  // use V8's serialize & deserialize for Structured Clone
  const { serialize, deserialize } = require('v8')

  export function local_channel() ::
    const { dispatch } = this
    const chan = @{}
      __proto__: this._channel_
      send, is_local: true
      addRoute: null,

    return chan

    function send(pkt) ::
      const pkt0 = pkt
      if undefined !== pkt.on_sent ::
        // shallow pre-clone
        pkt = o_assign({}, pkt)
        delete pkt.on_sent

      return _post_sent @ pkt0,
        _send_ex @ serialize @ pkt

    async function _send_ex(pkt) ::
      try ::
        pkt = deserialize @ await pkt
        return dispatch(pkt, chan)
      catch err ::
        chan.on_dispatch_error @ pkt, err

#ELSE
  // use MessageChannel for Structured Clone
  export function local_channel() ::
    const { dispatch } = this
    const { port1, port2 } = new MessageChannel()
    port2.onmessage = _send_ex

    const map = new Map()
    let q=[], pkt_id=1

    const chan = @{}
      __proto__: this._channel_
      send, is_local: true
      addRoute: null,

    return chan

    function send(pkt) ::
      const pkt0 = pkt
      if undefined !== pkt.on_sent ::
        // shallow pre-clone
        pkt = o_assign({}, pkt)
        delete pkt.on_sent

      return _post_sent @ pkt0,
        new Promise @ resolve => ::
          const id = q.pop() || pkt_id++
          map.set @ id, resolve
          port1.postMessage @# id, pkt

    function _send_ex(evt) ::
      const [id, pkt] = evt.data
      const resolve = map.get(id)
      map.delete(id)
      q.push(id)

      try ::
        return resolve @ dispatch(pkt, chan)
      catch err ::
        chan.on_dispatch_error @ pkt, err



