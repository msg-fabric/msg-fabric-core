import { o_assign, o_create } from './builtins.jsy'


export const channel_kinds = @{}
  raw_channel, send_channel, codec_channel, local_channel

export const base_channel = @{}
  __proto__: null
  channel_id: null

  toJSON() :: throw new Error @ 'Not serializable'

  undeliverable(pkt, mode) ::
    const {id_route, id_target} = pkt
    console.warn @ '~~ undeliverable',
      @{} mode, id_route, id_target

  on_send_error(err) ::
    console.warn @ '~~ channel send error', err

  addRoute(id_route, override) ::
    return this.router.addPeer @
      id_route, this, override

  get peerRoute() ::
    const p2p = this.p2p
    return p2p.peerRoute.bind(p2p)

  async init(channel_id) ::
    if undefined === this.peer_info ::
      this.peer_info = Promise.resolve(this.ready)
        .then @=> this.p2p ? this.p2p.hello() : null
      this.peer_info.catch(Boolean) // supress 'unhandled rejection' warnings

    if channel_id ::
      this.channel_id = channel_id
    return await this


const _typeof = v => typeof v
export function as_send_pkt(args) ::
  if 1 === args.length :: return args[0]
  return as_send_pkt[args.map(_typeof)] @ ...args

o_assign @ as_send_pkt, @{}
  'string,string,object'(id_route, id_target, body) ::
    return @{} id_route, id_target, body
  'object,object'(addr, body) ::
    return o_assign @ {body}, addr



export function raw_channel(p2p, unpack, chan_ex) ::
  const channel = o_assign @ o_create(this._channel_), chan_ex

  if null != p2p ::
    if ! p2p.hello || ! p2p.peerRoute ::
      throw new TypeError

    channel.p2p = p2p.initForChannel(channel)

  const r_disp = this.dispatch
  const recv = unpack
    ? async pkt => r_disp @ await unpack(await pkt), channel
    : async pkt => r_disp @ await pkt, channel

  return @[] recv, channel


export function send_channel(p2p, dispatch) ::
  return this.raw_channel @ p2p, null, @{}
    send: async (...args) =>
      await dispatch @ as_send_pkt @ args

    dispatch


export function codec_channel(p2p, dispatch, {encode, decode}) ::
  // see plugin/standard/json_codec.jsy for a codec implementation
  return this.raw_channel @ p2p, decode, @{}
    send: async (...args) =>
      dispatch @ await encode @ as_send_pkt @ args

    dispatch: async pkt =>
      dispatch @ await encode @ pkt



#IF PLAT_NODEJS
  // use V8's serialize & deserialize for Structured Clone
  const { serialize, deserialize } = require('v8')

  export function local_channel() ::
    const [recv, channel] = this.raw_channel @ null, deserialize, @{}
      is_local: true, addRoute: null,
      send: async (...args) =>
        recv @ await serialize @ as_send_pkt @ args

    return channel

    async function unpack(pkt_data) ::
      try :: return deserialize(pkt_data)
      catch err :: channel.on_send_error @ err

#ELSE
  // use MessageChannel for Structured Clone
  export function local_channel() ::
    const { port1, port2 } = new MessageChannel()
    port2.onmessage = on_msg

    const map = new Map()
    let q=[], pkt_id=1

    const [recv, channel] = this.raw_channel @ null, null, @{}
      send, is_local: true, addRoute: null

    return channel

    function send(...args) ::
      const pkt = as_send_pkt(args)
      return new Promise @ (... p_args) => ::
        const id = q.pop() || pkt_id++
        map.set @ id, p_args
        port1.postMessage @# id, pkt

    function on_msg(evt) ::
      const [id, pkt] = evt.data
      const [resolve, reject] = map.get(id)
      map.delete(id)
      q.push(id) // reuse id to avoid GC thrash

      let res
      try :: res = recv @ pkt
      catch err ::
        channel.on_send_error @ err
        return reject(err)

      return resolve(res)

