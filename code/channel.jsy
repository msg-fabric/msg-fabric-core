import { decode_utf8 } from './data_utils.jsy'

const o_assign = Object.assign, o_create = Object.create

export const channel_kinds = @{}
  send_channel, codec_channel, local_channel

export const base_channel = @{}
  __proto__: null
  channel_id: null

  toJSON() :: throw new Error @ 'Not serializable'

  undeliverable(pkt, mode) ::
    const {id_route, id_target} = pkt
    console.warn @ '~~ undeliverable',
      @{} mode, id_route, id_target

  on_dispatch_error(pkt, err) ::
    const {id_route, id_target} = pkt
    console.warn @ '~~ channel dispatch error',
      @{} id_route, id_target
      err

  on_send_error(err) ::
    console.warn @ '~~ channel send error', err

  addRoute(id_route, override) ::
    return this.router.addRoute @
      id_route, this.dispatch || this.send, override

  get peerRoute() ::
    const p2p = this.p2p
    return p2p.peerRoute.bind(p2p)

  async init(channel_id) ::
    if undefined === this.peer_info ::
      this.peer_info = Promise.resolve(this.ready)
        .then @=> this.p2p ? this.p2p.hello() : null

    if channel_id ::
      this.channel_id = channel_id
    return await this


function _init_p2p(chan, p2p) ::
  if null != p2p ::
    if ! p2p.hello || ! p2p.peerRoute ::
      throw new TypeError()

    chan.p2p = Object.create @ p2p, @{}
      channel: @{} value: chan
      router: @{} value: chan.router
  return chan

async function _post_sent(pkt, p) ::
  if undefined === pkt.on_sent ::
    return p

  const r = await p
  pkt.on_sent(pkt)
  return r



export function send_channel(p2p, send_ex) ::
  const { dispatch } = this
  const chan = @{}
    __proto__: this._channel_
    dispatch: send_ex, send

  _init_p2p(chan, p2p)
  return @[] recv, chan

  function send(pkt) ::
    return _post_sent @ pkt, send_ex @ pkt
  async function recv(pkt) ::
    return dispatch @ await pkt, chan


export function codec_channel(p2p, send_ex, codec) ::
  const { dispatch } = this
  const chan = @{}
    __proto__: this._channel_
    dispatch: resend, send

  _init_p2p(chan, p2p)
  return @[] recv, chan

  async function send(pkt) ::
    const pkt_data = await codec.encode @ pkt
    return _post_sent @ pkt, send_ex @ pkt_data
  async function resend(pkt) ::
    const pkt_data = await codec.encode @ pkt
    return send_ex @ pkt_data
  async function recv(pkt_data) ::
    const pkt = await codec.decode @ pkt_data
    return dispatch @ await pkt, chan

export const json_codec = @{}
  __proto__: null
  cache: new WeakMap()
  encode(pkt) ::
    let pkt_data = this.cache.get(pkt)
    if undefined === pkt_data ::
      pkt_data = JSON.stringify(pkt)
      this.cache.set(pkt, pkt_data)
    return JSON.stringify(pkt)
  decode(pkt_data) ::
    const pkt = JSON.parse @ 
      'string' === typeof pkt_data ? pkt_data
        : decode_utf8 @ pkt_data
    this.cache.set(pkt, pkt_data)
    return pkt




#IF PLAT_NODEJS
  // use V8's serialize & deserialize for Structured Clone
  const { serialize, deserialize } = require('v8')

  export function local_channel() ::
    const { dispatch } = this
    const chan = @{}
      __proto__: this._channel_
      send, is_local: true
      addRoute: null,

    return chan

    function send(pkt) ::
      const pkt0 = pkt
      if undefined !== pkt.on_sent ::
        // shallow pre-clone
        pkt = o_assign({}, pkt)
        delete pkt.on_sent

      return _post_sent @ pkt0,
        _send_ex @ serialize @ pkt

    async function _send_ex(pkt) ::
      try ::
        pkt = deserialize @ await pkt
        return dispatch(pkt, chan)
      catch err ::
        chan.on_dispatch_error @ pkt, err

#ELSE
  // use MessageChannel for Structured Clone
  export function local_channel() ::
    const { dispatch } = this
    const { port1, port2 } = new MessageChannel()
    port2.onmessage = _send_ex

    const map = new Map()
    let q=[], pkt_id=1

    const chan = @{}
      __proto__: this._channel_
      send, is_local: true
      addRoute: null,

    return chan

    function send(pkt) ::
      const pkt0 = pkt
      if undefined !== pkt.on_sent ::
        // shallow pre-clone
        pkt = o_assign({}, pkt)
        delete pkt.on_sent

      return _post_sent @ pkt0,
        new Promise @ resolve => ::
          const id = q.pop() || pkt_id++
          map.set @ id, resolve
          port1.postMessage @# id, pkt

    function _send_ex(evt) ::
      const [id, pkt] = evt.data
      const resolve = map.get(id)
      map.delete(id)
      q.push(id)

      try ::
        return resolve @ dispatch(pkt, chan)
      catch err ::
        chan.on_dispatch_error @ pkt, err



