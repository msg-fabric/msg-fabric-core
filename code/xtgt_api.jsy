import { p_res } from './builtins.jsy'

export function bindXTargetAPI(router_ctx) ::
  let xtgt_api = @{}
    __proto__: router_ctx
    // tgt_router: instance of some TargetRouter-like object
    // target: null || function (pkt, pktctx)
    // id: [id_route, id_target]

    is_active() ::
      return this.tgt_router.hasTarget @ this.id[1]

    enable(target) ::
      if undefined === target :: target = this.target
      this.tgt_router.addTarget @ this.id[1], target, this.target_opt

    disable() ::
      this.tgt_router.removeTarget @ this.id[1]

    use(target) ::
      this.enable @ this.target = target
      return this

    use_serial(target) ::
      let tip = p_res()
      return this.use @\ ...args ::
        let h = @=> target(...args)
        return tip = tip.then(h, h)


  let xresp_api = @{}
    __proto__: xtgt_api

    // awaitable / promise api
    then(y,n) :: return this.ans.then(y,n)
    catch(f) :: return this.ans.catch(f)
    finally(f) :: return this.ans.finally(f)

    until(p) ::
      let cancel = this.tgt_router.cancelTarget @ this.id[1]
      p.then(cancel, cancel)
      this.ans = p
      return this

    untilReply(ms_timeout, absent, on_reply) ::
      this.reset = _bind_untilReply(ms_timeout, absent, on_reply)
      return this.reset()
    reset: _bind_untilReply()


  return @{} xresp_api, xtgt_api


function _bind_untilReply(ms_timeout_p=1000, absent, on_reply) ::
  if undefined === on_reply ::
    on_reply = absent || @ pkt => pkt.body
    absent = undefined

  return function reset(ms_timeout=ms_timeout_p) ::
    return this.until @
      new Promise @\ resolve ::
        this.enable @ pkt => resolve @ on_reply(pkt)

        if ms_timeout ::
          this.timeouts.absent @
            ms_timeout, resolve, absent

