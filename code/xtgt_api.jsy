import { p_res } from './builtins.jsy'
import { defer_v } from './timeouts.jsy'

export function bindXTargetAPI(router_ctx) ::
  let xtgt_api = @{}
    __proto__: router_ctx
    // tgt_router: instance of some TargetRouter-like object
    // target: null || function (pkt, pktctx)
    // id: [id_route, id_target]

    is_active() ::
      return this.tgt_router.hasTarget(this.id[1])

    enable(target, opt=this.target_opt) ::
      if undefined === target ::
        target = this.target
      return this.tgt_router.addTarget @
        this.id[1], target, opt

    disable() ::
      return this.tgt_router.removeTarget(this.id[1])

    get cancel() ::
      return this.tgt_router.cancelTarget(this.id[1])

    use(target, opt) ::
      this.enable(this.target = target, opt)
      return this

    use_serial(target, opt) ::
      if undefined === target ::
        target = this.target

      let tip = p_res()
      return this.use(target_s, opt)

      function target_s(...args) ::
        let h = @=> target(...args)
        return tip = tip.then(h, h)


  let xresp_api = @{}
    __proto__: xtgt_api

    ms_timeout: 1000
    on_reply: pkt => pkt.body
    with(... args) ::
      let self = {__proto__: this}
      for let ea of args ::
        switch typeof ea ::
          case 'number': self.ms_timeout = ea ; break
          case 'function': self.on_reply = ea ; break
          case 'object': o_assign(self, ea) ; break
      return self

    async response(absent) ::
      let {cancel, ms_timeout} = this

      try ::
        let p=defer_v()

        this.enable(p[1])
        if ms_timeout ::
          this.timeouts.absent(
            ms_timeout, p[1], absent)

        let ans = await p[0]
        return ans === absent ? absent
          : this.on_reply(ans)
      finally ::
        cancel()


  return @{} xresp_api, xtgt_api

