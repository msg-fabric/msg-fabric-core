/*
  0123456789ab -- 12-byte message packet
  
  01.......... -- uint16 signature = 0xFE 0xED
  ..23 ....... -- uint16 packet length

  ....4....... -- uint8 ttl hops

  .....5...... -- uint8 header type
  ......67.... -- uint8 header length

  ........89ab -- uint32 id_router
                    4-byte random space allows 1 million nodes with
                    0.02% chance of two nodes selecting the same id
 */
export const pkt_header_size = 12
export const signature = 0xedfe
export const pkt_details = @{}
  signature, pkt_header_size


export default packetStreamParser
export function packetStreamParser(options={}) ::
  const decrement_ttl =
    null == options.decrement_ttl
      ? true : !! options.decrement_ttl

  let tip=null, qByteLen = 0, q = []

  return Object.assign @ feed, @{}
    feed, clone, parseHeader, packMessage
    pkt_details

  function clone(opt) ::
    opt = Object.assign @ {}, options, opt
    return packetStreamParser(opt)

  function feed(data_buffer, complete=[]) ::
    if ! Buffer.isBuffer @ data_buffer ::
      throw new TypeError @ `Expect packetStreamParser::feed 'data_buffer' parameter as a Buffer instance`
    q.push @ data_buffer
    qByteLen += data_buffer.byteLength

    while 1 ::
      const msg = parseTipMessage()
      if undefined !== msg ::
        complete.push @ msg
      else return complete


  function parseTipMessage() ::
    if null === tip ::
      if qByteLen < pkt_header_size ::
        return

      else if q.length > 1 ::
        q = @[] Buffer.concat(q)

      tip = parseHeader @ q[0]

    const len = tip.packet_len
    if qByteLen < len ::
      return

    let bytes = 0, n = 0, msg_buffer
    while bytes < len ::
      bytes += q[n++].byteLength

    const trailingBytes = bytes - len
    if 0 === trailingBytes :: // we have an exact length match
      const parts = q.splice(0, n)
      qByteLen -= len

      msg_buffer = Buffer.concat @ parts

    else :: // we have trailing bytes on the last array
      const parts = 1 === q.length ? [] : q.splice(0, n-1)
      const tail = q[0]

      parts.push @ tail.slice(0, -trailingBytes)
      q[0] = tail.slice(-trailingBytes)
      qByteLen -= len

      msg_buffer = Buffer.concat @ parts

    ::
      const msg_obj = Object.defineProperties @ tip, @:
        _raw_: @{} value: msg_buffer

      tip = null
      return msg_obj

  function parseHeader(buf) ::
    const sig = buf.readUInt16LE @ 0
    if signature !== sig ::
      throw new Error @ `Packet stream framing error (found: ${sig.toString(16)} expected: ${signature.toString(16)})`

    // up to 64k packet length; length includes header
    const packet_len = buf.readUInt16LE @ 2
    const header_len = Math.min @ packet_len - pkt_header_size, buf.readUInt16LE @ 4
    const type = buf.readUInt8 @ 6

    let ttl = buf.readUInt8 @ 7
    if decrement_ttl ::
      ttl = Math.max @ 0, ttl - 1
      buf.writeUInt8 @ ttl, 7

    const id_router = buf.readUInt32LE @ 8

    const msg_obj = Object.assign @
      Object.create @ msg_obj_proto, @:
        packet_len: @{} value: packet_len
        body_offset: @{} value: pkt_header_size + header_len

      @{} type, ttl, id_router
    return msg_obj

const msg_obj_proto = @:
  sliceBody() ::
    return this._raw_.slice @ this.body_offset
  sliceHeader() ::
    return this._raw_.slice @ pkt_header_size, this.body_offset



export function packMessage(...args) ::
  let {type, ttl, id_router, header, body} = Object.assign @ {}, ...args
  header = _asBuffer(header)
  body = _asBuffer(body)

  const len = pkt_header_size + header.byteLength + body.byteLength
  if len > 0xffff :: throw new Error @ `Packet too large`

  const pkt = Buffer.allocUnsafe @ pkt_header_size
  pkt.writeUInt16LE @ signature, 0
  pkt.writeUInt16LE @ len, 2
  pkt.writeUInt16LE @ header.byteLength, 4
  pkt.writeUInt8 @ type || 0, 6
  pkt.writeUInt8 @ ttl || 31, 7
  pkt.writeUInt32LE @ id_router || 0, 8

  return Buffer.concat @# pkt, header, body


function _asBuffer(buf) ::
  if Buffer.isBuffer(buf) ::
    return buf
  if Array.isArray(buf) ::
    if Number.isSafeInteger @ buf[0] ::
      return Buffer.from(buf)
    else ::
      return Buffer.concat @ buf.map @ _asBuffer
  return Buffer.from(buf || '')

