/*
  0123456789ab     -- 12-byte packet header (control)
  0123456789abcdef -- 16-byte packet header (routing)
  
  01.............. -- uint16 signature = 0xFE 0xED
  ..23 ........... -- uint16 packet length

  ....4........... -- uint8 ttl hops

  .....5.......... -- uint8 header type
  ......67........ -- uint8 header length

  ........89ab.... -- uint32 id_router
                      4-byte random space allows 1 million nodes with
                      0.02% chance of two nodes selecting the same id

  ............cdef -- uint32 id_target (when id_router !== 0)
                      4-byte random space allows 1 million nodes with
                      0.02% chance of two nodes selecting the same id
 */
export const pkt_control_header_size = 12
export const pkt_routing_header_size = 16
export const signature = 0xedfe
export const pkt_details = @{}
  signature, pkt_control_header_size, pkt_routing_header_size


export default packetStreamParser
export function packetStreamParser(options={}) ::
  const decrement_ttl =
    null == options.decrement_ttl
      ? true : !! options.decrement_ttl

  let tip=null, qByteLen = 0, q = []

  return Object.assign @ feed, @{}
    feed, clone, parseHeader, packMessage, packMessageObj
    pkt_details

  function clone(opt) ::
    opt = Object.assign @ {}, options, opt
    return packetStreamParser(opt)

  function feed(data_buffer, complete=[]) ::
    if ! Buffer.isBuffer @ data_buffer ::
      throw new TypeError @ `Expect packetStreamParser::feed 'data_buffer' parameter as a Buffer instance`
    q.push @ data_buffer
    qByteLen += data_buffer.byteLength

    while 1 ::
      const msg = parseTipMessage()
      if undefined !== msg ::
        complete.push @ msg
      else return complete


  function parseTipMessage() ::
    if null === tip ::
      if qByteLen < pkt_control_header_size ::
        return

      else if q.length > 1 ::
        q = @[] Buffer.concat(q)

      tip = parseHeader @ q[0]
      if null === tip :: return

    const len = tip.packet_len
    if qByteLen < len ::
      return

    let bytes = 0, n = 0, msg_buffer
    while bytes < len ::
      bytes += q[n++].byteLength

    const trailingBytes = bytes - len
    if 0 === trailingBytes :: // we have an exact length match
      const parts = q.splice(0, n)
      qByteLen -= len

      msg_buffer = Buffer.concat @ parts

    else :: // we have trailing bytes on the last array
      const parts = 1 === q.length ? [] : q.splice(0, n-1)
      const tail = q[0]

      parts.push @ tail.slice(0, -trailingBytes)
      q[0] = tail.slice(-trailingBytes)
      qByteLen -= len

      msg_buffer = Buffer.concat @ parts

    ::
      const msg_obj = Object.defineProperties @ tip, @:
        _raw_: @{} value: msg_buffer

      tip = null
      return msg_obj

  function parseHeader(buf) ::
    const sig = buf.readUInt16LE @ 0
    if signature !== sig ::
      throw new Error @ `Packet stream framing error (found: ${sig.toString(16)} expected: ${signature.toString(16)})`

    // up to 64k packet length; length includes header
    const packet_len = buf.readUInt16LE @ 2
    let header_len = buf.readUInt16LE @ 4
    const type = buf.readUInt8 @ 6

    let ttl = buf.readUInt8 @ 7
    if decrement_ttl ::
      ttl = Math.max @ 0, ttl - 1
      buf.writeUInt8 @ ttl, 7

    const id_router = buf.readUInt32LE @ 8
    let id_target, header_offset
    if 0 === id_router ::
      header_offset = pkt_control_header_size
    else if pkt_routing_header_size > buf.byteLength ::
      return null // this buffer is fragmented before id_target
    else ::
      id_target = buf.readUInt32LE @ 12
      header_offset = pkt_routing_header_size

    let body_offset = header_offset + header_len
    if body_offset > packet_len ::
      body_offset = null // invalid message construction
      
    const msg_obj = Object.assign @
      Object.create @ msg_obj_proto, @:
        header_offset: @{} value: header_offset
        body_offset: @{} value: body_offset
        packet_len: @{} value: packet_len

      @{} type, ttl, id_router, id_target
    return msg_obj

  function packMessageObj(...args) ::
    const msg_buffer = packMessage @ ...args
    const msg_obj = parseHeader @ msg_buffer
    Object.defineProperties @ msg_obj, @:
      _raw_: @{} value: msg_buffer
    return msg_obj

const msg_obj_proto = @:
  sliceBody() ::
    return this._raw_.slice @ this.body_offset
  sliceHeader() ::
    return this._raw_.slice @ this.header_offset, this.body_offset



export function packMessage(...args) ::
  let {type, ttl, id_router, id_target, header, body} = Object.assign @ {}, ...args
  header = _asBuffer(header)
  body = _asBuffer(body)

  const pkt_header_size = id_router
    ? pkt_routing_header_size
    : pkt_control_header_size
  const packet_len = pkt_header_size + header.byteLength + body.byteLength
  if packet_len > 0xffff :: throw new Error @ `Packet too large`

  const pkt = Buffer.alloc @ pkt_header_size
  pkt.writeUInt16LE @ signature, 0
  pkt.writeUInt16LE @ packet_len, 2
  pkt.writeUInt16LE @ header.byteLength, 4
  pkt.writeUInt8 @ type || 0, 6
  pkt.writeUInt8 @ ttl || 31, 7
  if ! id_router ::
    pkt.writeUInt32LE @ 0, 8
    if id_target ::
      throw new Error @ `Invalid id_target for control packet`
  else ::
    pkt.writeUInt32LE @ id_router, 8
    pkt.writeUInt32LE @ id_target || 0, 12

  const buf = Buffer.concat @# pkt, header, body
  if packet_len !== buf.byteLength ::
    throw new Error @ `Packed message length mismatch (library error)`
  return buf


function _asBuffer(buf) ::
  if Buffer.isBuffer(buf) ::
    return buf
  if Array.isArray(buf) ::
    if Number.isSafeInteger @ buf[0] ::
      return Buffer.from(buf)
    else ::
      return Buffer.concat @ buf.map @ _asBuffer
  return Buffer.from(buf || '')

