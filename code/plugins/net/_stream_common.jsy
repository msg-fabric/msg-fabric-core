export const channel_base = @{}
  undeliverable(pkt, mode) ::
    console.warn @ `Undeliverable[${mode}]: target '${pkt.id_target}' of route '${pkt.id_route}'`

  sendRoutingHandshake(hub) ::
    return this.send @:
      id_target: 'hello', id_route: ''
      body: hub.p2p.id_route_list


export default stream_common
export function stream_common(hub) ::
  const createRWChannel = bind_channelDispatch(hub, channel_base)
  return @{} channel_base, createRWChannel


export function bind_channelDispatch(hub, channel_base) ::
  const {dispatch} = hub, {packBinaryPacket, unpackBinaryPacket} = hub._pkts_node_
  const pktDispatch = function (channel, pktList) ::
    pktList = pktList.map(unpackBinaryPacket)
    return dispatch @ pktList, channel

  return function (rstream, wstream, chan_base=channel_base) ::
    const channel = Object.create @ chan_base, @{}
      send: @{} value: send

    recvPacketStream @ rstream, pktDispatch.bind(null, channel)
    return channel

    function send(...objs) ::
      if null === objs[0] ::
        return void wstream.end()
      for const obj of objs ::
        const buf = packBinaryPacket(obj)
        wstream.write(buf)


export function recvPacketStream(rstream, dispatchCallback) ::
  return new Promise @ (resolve, reject) => ::
    rstream.on @ 'error', shutdown
    rstream.on @ 'close', shutdown
    rstream.on @ 'data'
      binaryLenPrefixFeedUint16LE @ shutdown, dispatchCallback

    function shutdown(err) ::
      if undefined !== rstream ::
        rstream.end()
        rstream = undefined
        err ? reject(err) : resolve()



export function binaryLenPrefixFeedUint16LE(shutdown, dispatchCallback) ::
  let tipLen=null, byteLen=0, q=[]

  return function(data) ::
    q.push(data) ; byteLen += data.byteLength

    const pktList = []
    while 1 ::
      const buf = parseNext()
      if undefined !== buf ::
        pktList.push @ buf
      else if 0 !== pktList.length ::
        try ::
          return dispatchCallback(pktList)
        catch err ::
          return shutdown(err)

  function parseNext() ::
    if null === tipLen ::
      if byteLen < 2 :: return

      const buf = Buffer.concat(q)
      tipLen = buf.readUInt16LE(0)
      q = [buf]

      if tipLen < 4 ::
        shutdown @ new Error @ 'Binary stream framing error'
        return

    if tipLen <= byteLen ::
      const buf_q = 1===q.length ? q[0]
        : Buffer.concat(q)

      const buf = buf_q.slice(0, tipLen)
      q = [buf_q.slice(tipLen)]
      byteLen -= tipLen
      tipLen = null
      return buf

