import {URL} from 'url'
import {createServer, createConnection} from 'net'

module.exports = exports = net_plugin
export default net_plugin
export function net_plugin(hub) ::
  return hub.net = @:
    connect(...args) ::
      if 1 === args.length && 'string' === typeof args[0] ::
        const {hostname:host, port} = new URL(args[0])
        args = @# @{} host, port

      return new Promise @ (resolve, reject) => ::
        createConnection @ ...args, function () ::
          const sock = this
          const sendMsgRaw = bindSendMsgRaw(sock, hub)
          resolve(sendMsgRaw.api)

        .on @ 'error', reject

    createServer(onPeer) ::
      const svr = createServer @ sock => ::
        const sendMsgRaw = bindSendMsgRaw(sock, hub)

        if 'function' === typeof onPeer ::
          onPeer @ sendMsgRaw.api
        else if 'string' === typeof onPeer ::
          svr.emit @ onPeer, sendMsgRaw.api

      return svr

export function bindSendMsgRaw(sock, hub) ::
  sock.unref()
  sock.setNoDelay()
  sock.setKeepAlive(true)

  const conn_info = @{}
    ip_remote: @{}
      address: sock.remoteAddress
      port: sock.remotePort

    ip_local: @{}
      address: sock.localAddress
      port: sock.localPort

  sendMsgRaw.api = Object.create @
    hub._api_channel, @:
      sendRaw: @: value: sendMsgRaw
      conn_info: @: value: conn_info, enumerable: true

  hub.on_connect_peer @ sock, sendMsgRaw
  return sendMsgRaw

  function sendMsgRaw(msg, asPromise) ::
    if null === msg ::
      return void sock.end()
    if ! asPromise ::
      return void sock.write(msg)
    return new Promise @ function (resolve, reject) ::
      sock.write @ msg, err => err ? reject(err) : resolve()
