import {URL} from 'url'
import tcp_plugin from './tcp'

module.exports = exports = net_plugin
export default net_plugin
export function net_plugin(plugin_options={}) ::
  const tcp = tcp_plugin(plugin_options)
  return function(hub) ::
    return hub.net = tcp(hub)


export function net_common(hub, asURL) ::
  // shared implementation between net/tcp and tls implementations
  return @:
    init_server(svr) ::
      svr.conn_info = function () ::
        const {address, port} = svr.address()
        return @{} ip_server: @{} address, port, asURL
      return svr

    bindOnPeer(svr, onPeer) ::
      if 'function' === typeof onPeer ::
        return onPeer
      if 'string' === typeof onPeer ::
        return channel => svr.emit @ onPeer, channel
      return () => null

    bindChannel(sock) ::
      return bindSendMsgRaw(sock, hub, asURL).api

    unpackConnectArgs(args) ::
      if 1 === args.length ::
        const conn_url = args[0]
        if 'string' === typeof conn_url || conn_url instanceof URL ::
          const {hostname:host, port} = new URL(conn_url)
          args = @# @{} host, port
      return args



export function bindSendMsgRaw(sock, hub, asURL) ::
  sock.unref()
  sock.setNoDelay()
  sock.setKeepAlive(true)

  const conn_info = () => @:
    ip_remote: @{} asURL, address: sock.remoteAddress, port: sock.remotePort
    ip_local: @{} asURL, address: sock.localAddress, port: sock.localPort

  sendMsgRaw.api = Object.create @
    hub._api_channel, @:
      sendRaw: @: value: sendMsgRaw
      conn_info: @: value: conn_info

  hub.on_connect_peer_stream @
    sock, sendMsgRaw

  sendMsgRaw.shutdown
    .catch @ () => null
    .then @ () => sock.end()
  return sendMsgRaw

  function sendMsgRaw(msg, asPromise) ::
    if null === msg ::
      return void sock.end()
    if ! asPromise ::
      return void sock.write(msg)
    return new Promise @ function (resolve, reject) ::
      sock.write @ msg, err => err ? reject(err) : resolve()


