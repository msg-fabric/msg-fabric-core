import {URL} from 'url'
import {createServer, createConnection} from 'net'

module.exports = exports = net_plugin
export default net_plugin
export function net_plugin(hub) ::
  return hub.net = @:
    connect(...args) ::
      if 1 === args.length && 'string' === typeof args[0] ::
        const {hostname:host, port} = new URL(args[0])
        args = @# @{} host, port

      return new Promise @ (resolve, reject) => ::
        createConnection @ ...args, function () ::
          const sock = this
          const sendMsgRaw = bindSendMsgRaw(sock)
          resolve(sendMsgRaw)

          hub.on_connect_peer @ sock, sendMsgRaw
          .catch @ console.error

        .on @ 'error', reject

    createServer(onPeer) ::
      const svr = createServer @ sock => ::
        const sendMsgRaw = bindSendMsgRaw(sock, hub)

        hub.on_connect_peer @ sock, sendMsgRaw
        .catch @ console.error

        if 'function' === typeof onPeer ::
          onPeer @ sendMsgRaw
        else if 'string' === typeof onPeer ::
          svr.emit @ onPeer, sendMsgRaw

      return svr

export function bindSendMsgRaw(sock) ::
  sock.unref()
  sock.setNoDelay()
  sock.setKeepAlive(true)

  sendMsgRaw.conn_info = @{}
    ip_remote: @{}
      address: sock.remoteAddress
      port: sock.remotePort

    ip_local: @{}
      address: sock.localAddress
      port: sock.localPort

  return sendMsgRaw

  function sendMsgRaw(msg, asPromise) ::
    if null === msg ::
      return void sock.end()
    if ! asPromise ::
      return void sock.write(msg)
    return new Promise @ function (resolve, reject) ::
      sock.write @ msg, err => err ? reject(err) : resolve()
