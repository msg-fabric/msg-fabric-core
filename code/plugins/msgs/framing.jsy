const b16_unpack = v => parseInt(v, 16)|0
const b16_pack = v => (v|0).toString(16)
const is_defined = (attr, v) => ::
  if undefined === v :: throw new Error(attr)
  return v


const f_msgid = @{} attr: 'msgid'
  unpack: (v, hdr) => :: hdr.msgid = v
  pack: hdr => is_defined @ 'msgid', hdr.msgid

const f_token = @{} attr: 'token'
  unpack: (v, hdr) => :: hdr.token = v
  pack: hdr => is_defined @ 'token', hdr.token

const f_from_route = @{} attr: 'from_route'
  unpack: (v, hdr) => :: hdr.from_route = v
  pack: hdr => is_defined @ 'from_route', hdr.from_route

const f_from_target = @{} attr: 'from_target'
  unpack: (v, hdr) => :: hdr.from_target = v
  pack: hdr => is_defined @ 'from_target', hdr.from_target

const f_seq = @{} attr: 'seq'
  unpack: (v, hdr) => :: hdr.seq = b16_unpack @ v
  pack: hdr => b16_pack @ is_defined @ 'seq', hdr.seq

const f_ackseq = @{} attr: 'ackseq'
  unpack: (v, hdr) => :: hdr.ackseq = b16_unpack @ v
  pack: hdr => b16_pack @ is_defined @ 'ackseq', hdr.ackseq


function as_op(transport, op_key, frames) ::
  frames.unshift @: attr: 'op_key'
    unpack: (v, hdr) => :: hdr.transport = transport
    pack: hdr => op_key

  const f_pack = frames.map @ f => f.pack.bind(f)
  const pack = _as_pack_fn[frames.length] @ ... f_pack

  const f_unpack = frames.map @ f => f.unpack.bind(f)
  const unpack = _as_unpack_fn[frames.length] @ ... f_unpack

  return @{} transport, op_key
    attrs: frames.map @ f => f.attr
    pack, unpack, bind

  function bind(opo0) ::
    return (obj, hdr) => ::
      obj.op = pack @ Object.assign @ {}, opo0, hdr
      return obj


// unroll looping over the functions
const _as_pack_fn = @[]
  () => hdr => @#
  (f0) => hdr => @# f0(hdr)
  (f0, f1) => hdr => @# f0(hdr), f1(hdr)
  (f0, f1, f2) => hdr => @# f0(hdr), f1(hdr), f2(hdr)
  (f0, f1, f2, f3) => hdr => @# f0(hdr), f1(hdr), f2(hdr), f3(hdr)
  (f0, f1, f2, f3, f4) => hdr => @# f0(hdr), f1(hdr), f2(hdr), f3(hdr), f4(hdr)

// unroll looping over the functions
const _as_unpack_fn = @[]
  () => (hdr, op) => @ op
  (f0) => (hdr, op) => @ f0(hdr[2], op), op
  (f0, f1) => (hdr, op) => @ f0(hdr[2], op), f1(hdr[3], op), op
  (f0, f1, f2) => (hdr, op) => @ f0(hdr[2], op), f1(hdr[3], op), f2(hdr[4], op), op
  (f0, f1, f2, f3) => (hdr, op) => @ f0(hdr[2], op), f1(hdr[3], op), f2(hdr[4], op), f3(hdr[5], op), op
  (f0, f1, f2, f3, f4) => (hdr, op) => @ f0(hdr[2], op), f1(hdr[3], op), f2(hdr[4], op), f3(hdr[5], op), f4(hdr[6], op), op



const p_datagram = 'p_datagram'
const p_direct = 'p_direct'
const p_multipart = 'p_multipart'
const p_stream ='p_stream'
export const all_ops = @[]
  // datagram:
  as_op @ p_datagram, '-', @#
  as_op @ p_datagram, '@', @# f_from_route, f_from_target

  // direct: 
  as_op @ p_direct, 'E', @# f_token
  as_op @ p_direct, 'e', @# f_msgid
  //as_op @ p_direct, 'f', @# f_msgid, f_ackseq
  as_op @ p_direct, 'D', @# f_from_route, f_from_target, f_token
  as_op @ p_direct, 'd', @# f_from_route, f_from_target, f_msgid

  // multipart:
  as_op @ p_multipart, 'U', @# f_token, f_seq
  //as_op @ p_multipart, 'u', @# f_msgid, f_seq, f_ackseq
  as_op @ p_multipart, 'T', @# f_from_route, f_from_target, f_token, f_seq
  //as_op @ p_multipart, 't', @# f_from_route, f_from_target, f_msgid, f_ackseq

  // streaming:
  as_op @ p_stream, 'R', @# f_token, f_seq
  //as_op @ p_stream, 'r', @# f_msgid, f_seq, f_ackseq
  as_op @ p_stream, 'S', @# f_from_route, f_from_target, f_token, f_seq
  //as_op @ p_stream, 's', @# f_from_route, f_from_target, f_msgid, f_ackseq


const op_unpack_table = @{} '': ident, ' ': ident
all_ops.forEach @ op => :: op_unpack_table[op.op_key] = op.unpack


function ident(op) :: return op
export function op_unpack(pkt) ::
  const hdr = pkt._hdr_, op = hdr.op = {}
  const unpack = op_unpack_table[hdr[2]] || ident
  unpack(hdr, op)
  return op



function as_bindable(...ops_list) ::
  ops_list = [].concat @ ...ops_list
  return opo0 => ::
    const api = {}
    for const op of ops_list ::
      const fn = op.bind(opo0)
      fn.op = op.op_key
      api[op.transport] = fn
    return api

const find_ops = ({has, sans}) => all_ops.filter @ op => @
     @ !has  || has .split(' ').every @ a => op.attrs.includes @ a
  && @ !sans || sans.split(' ').every @ a => ! op.attrs.includes @ a



const basic_from_ops = find_ops @: has: 'from_route', sans: 'token msgid'

export const source_ops_api = as_bindable @
  basic_from_ops
  find_ops @: has: 'from_route', sans: 'msgid'

export const reply_ops_api = as_bindable @
  basic_from_ops
  find_ops @: has: 'from_route msgid'



const basic_anon_ops = find_ops @: sans: 'from_route token msgid'

export const anon_source_ops_api = as_bindable @
  basic_anon_ops
  find_ops @: sans: 'from_route msgid'

export const anon_reply_ops_api = as_bindable @
  basic_anon_ops
  find_ops @: has: 'msgid', sans: 'from_route'

