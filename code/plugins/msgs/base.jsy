import {deferred} from './util.jsy'

export const sym_sampi = '\u03E0' // 'Ï '


export function as_source_id(id) ::
  return 'string' === typeof id ? id.split(' ', 2)
    : 'string' === typeof id[sym_sampi] ? id[sym_sampi].split(' ', 2)
    : @[] id.id_route, id.id_target

export function as_reply_id(id) ::
  return 'string' === typeof id ? id.split(' ', 2)
    : 'string' === typeof id[sym_sampi] ? id[sym_sampi].split(' ', 2)
    : @[] id.from_route, id.from_target


export function bind_createContext(newToken, expire) ::
  return () => ::
    let db = new Map()
    return @{} newToken
      responseFor(token) ::
        const d = deferred()
        db.set @ token, d

        expire @ d.reject
        const remove = @=> db.delete(token)
        d.promise.then @ remove, remove
        return d.promise

      on_response(token, response) ::
        let d = db.get(token)
        if undefined === d ::
          d = db0.get(token)
          if undefined === d ::
            return
          db0.delete(token)
        else db.delete(token)

        d.resolve(response)


export function bind_msg_api({chan, op_api, ctx, id_route, id_target, anon}) ::
  return @{} __proto__: null, anon
    post(body) ::
      const obj = @{} id_route, id_target, body

      // TODO: choose between op_api.datagram and op_api.multipart
      const pkt = op_api.datagram @ obj
      chan.send(pkt)

    send(body) ::
      const token = ctx.newToken()
      const response = ctx.responseFor(token)

      // TODO: choose between op_api.direct and op_api.multipart
      const obj = @{} id_route, id_target, body
      const pkt = op_api.direct @ obj, {token}
      chan.send(pkt)

      return response

    multipart() :: return wstreamop_api.multipart
    stream() :: return wstreamop_api.stream

    toJSON(obj={}) ::
      obj[sym_sampi] = `${id_route} ${id_target}`
      return obj

  function wstream(op_method) ::
    let seq = 1
    const token = ctx.newToken()
    const self = @{} write, end
      response: ctx.responseFor(token)
    return self

    function write(body) ::
      const obj = @{} id_route, id_target, body
      const pkt = op_method @ obj, {seq: seq++}
      chan.send(pkt)
      return self

    function end(body) ::
      seq = -seq
      write(body)
      seq = null
      return self

