import {deferred, timeoutReaper} from './util.jsy'

export const sym_sampi = '\u03E0' // 'Ϡ'


export function as_source_id(id) ::
  return 'string' === typeof id ? id.split(' ', 2)
    : 'string' === typeof id[sym_sampi] ? id[sym_sampi].split(' ', 2)
    : @[] id.id_route, id.id_target

export function as_reply_id(id) ::
  return 'string' === typeof id ? id.split(' ', 2)
    : 'string' === typeof id[sym_sampi] ? id[sym_sampi].split(' ', 2)
    : @[] id.from_route, id.from_target



export function bind_mx_api(source_api, reply_api) ::
  return (pkt_op, _mx_) => ::
    const props = @{}
      _mx_: {value: _mx_}
      [sym_sampi]: @{} enumerable: true,
        value: `${_mx_.id_route} ${_mx_.id_target}`

    if null != pkt_op && pkt_op.token ::
      _mx_.opo0.msgid = pkt_op.token
      return Object.create @ reply_api, props
    return Object.create @ source_api, props


export default msg_base_api
export function msg_base_api(hub, options) ::
  const _pkts_ = hub._pkts_
  const random = hub.data_utils.random

  const chan = options.channel || hub.channel
  const tokenLen = Math.max @ 1, options.tokenLen || 3 | 0
  const expire = timeoutReaper @ options.timeout || 5000
  const newToken = () => random(tokenLen, true)

  const msg_api0 = bind_msg_api0()

  return @{}
    newToken, expire, msg_api0

    createContext() ::
      let db = new Map()
      return @{} newToken
        deferredFor(token) ::
          if ! token :: return
          let d = db.get(token)
          if undefined !== d :: return d
          d = deferred()
          db.set(token, d)

          expire(d.reject)
          const remove = @=> db.delete(token)
          d.promise.then @ remove, remove
          return d

        responseFor(token) ::
          return this.deferredFor(token).promise

        on_resolve(msgid, ans) ::
          if ! msgid :: return ans
          const d = db.get(msgid)
          if undefined === d :: return ans
          db.delete(msgid)
          d.resolve(ans)
          return null

        on_split_pkt(pkt, op) ::
          const key = '~ ' + (op.token || op.msgid)
          let d = db.get(key)
          if undefined === d ::
            d = this.deferredFor(key)
            d.feed = this.on_new_split(key, d)
          else if undefined === d.feed ::
            d.feed = this.on_new_split(key, d)

          pkt.complete = d.promise
          return d.feed(pkt, op)

        on_new_split(key, d) ::
          let fin, parts=[]
          return function (pkt, op) ::
            const {seq} = op
            if seq >= 0 ::
              parts[seq] = pkt
              if ! fin :: return null
            else ::
              parts[-seq] = pkt
              fin = true

            if ! parts.includes(undefined) ::
              // all parts accounted for
              const multi = _pkts_.joinPackets(parts)
              parts = null
              d.resolve(multi)
              db.delete(key)
              return multi
            return null


    bind_msg_api({anon, op_api}) ::
      return @{} __proto__: msg_api0, anon

        send(body) ::
          const {msgid} = this._mx_.opo0
          return msgid ? this._withResponse(body) : this.post(body)

        answer(body) :: return this._withResponse(body)
        query(body) :: return this._withResponse(body)

        post(body) ::
          const parts = _pkts_.splitBody(body)
          if 1 < parts.length ::
            const {opo} = this._new_token()
            return this._msend(parts, opo)

          const {id_route, id_target, opo0} = this._mx_
          const obj = @{} id_route, id_target, body: parts[0]
          const pkt = op_api.datagram @ obj, opo0
          this._send_pkt(pkt)


        _withResponse(body) ::
          const {response, opo} = this._new_response()

          const parts = _pkts_.splitBody(body)
          if 1 < parts.length ::
            return this._msend(parts, opo, response)

          const {id_route, id_target} = this._mx_
          const obj = @{} id_route, id_target, body: parts[0]
          const pkt = op_api.direct @ obj, opo
          this._send_pkt(pkt)
          return response


        stream() ::
          const {response, opo} = this._new_response()
          return this._wstream(opo, op_api.stream, response)

        multipart() ::
          const {response, opo} = this._new_response()
          return this._wstream(opo, op_api.multipart, response)

        _msend(parts, opo, response) ::
          return this._wstream(opo, op_api.multipart, response)
            .writeAll(parts, true)
            .response

        ctrl(body) ::
          const {response, opo} = this._new_response()
          const {id_route, id_target} = this._mx_
          const obj = @{} id_route, id_target, body
          const pkt = op_api.ctrl @ obj, opo
          this._send_pkt(pkt)
          return response


  function bind_msg_api0() ::
    return @{} __proto__: null
      inspect() :: return `«${sym_sampi} ${this[sym_sampi]}»`
      toJSON(obj={}) :: obj[sym_sampi] = this[sym_sampi]; return obj

      _new_token() ::
        const {ctx, opo0} = this._mx_
        const token = ctx.newToken()
        return @{} token,
          opo: Object.assign @ {token}, opo0

      _new_response() ::
        const {ctx, opo0} = this._mx_
        if opo0.msgid :: return @{} opo: opo0

        const token = ctx.newToken()
        return @{} token,
          opo: Object.assign @ {token}, opo0
          response: ctx.responseFor(token)

      _send_pkt(pkt) :: chan.send(pkt)

      _wstream(opo, op_method, response) ::
        const {id_route, id_target} = this._mx_
        let seq=0, self
        return self = @{} response
          write: body => ::
            const obj = @{} id_route, id_target, body
            const pkt = op_method @ obj,
              Object.assign({seq: seq++}, opo)
            this._send_pkt(pkt)
            return self

          writeAll: (body, close) => ::
            let cur, next
            for next of body ::
              if undefined !== cur ::
                self.write(cur)
              cur = next

            return undefined === cur ? self
              : close ? self.end(cur)
                : self.write(cur)

          end: body => ::
            seq = -seq
            self.write(body)
            seq = null
            return self

