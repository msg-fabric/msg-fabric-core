import {deferred, timeoutReaper} from './util.jsy'

export const sym_sampi = '\u03E0' // 'Ϡ'


export function as_source_id(id) ::
  return 'string' === typeof id ? id.split(' ', 2)
    : 'string' === typeof id[sym_sampi] ? id[sym_sampi].split(' ', 2)
    : @[] id.id_route, id.id_target

export function as_reply_id(id) ::
  return 'string' === typeof id ? id.split(' ', 2)
    : 'string' === typeof id[sym_sampi] ? id[sym_sampi].split(' ', 2)
    : @[] id.from_route, id.from_target



export function bind_mx_api(source_api, reply_api) ::
  return (pkt_op, _mx_) => ::
    const props = @{}
      _mx_: {value: _mx_}
      [sym_sampi]: @{} enumerable: true,
        value: `${_mx_.id_route} ${_mx_.id_target}`

    if null != pkt_op && pkt_op.token ::
      _mx_.opo0.msgid = pkt_op.token
      return Object.create @ reply_api, props
    return Object.create @ source_api, props


export default msg_base_api
export function msg_base_api(hub, options) ::
  const { _pkts_ } = hub
  const { random } = hub.data_utils

  const chan = options.channel || hub.channel
  const tokenLen = Math.max @ 1, options.tokenLen || 3 | 0
  const expire = timeoutReaper @ options.timeout || 5000
  const newToken = () => random(tokenLen, true)

  const msg_api0 = bind_msg_api0()

  return @{}
    newToken, expire, msg_api0

    createContext() ::
      let db = new Map()
      return @{} newToken
        responseFor(token) ::
          if ! token :: return
          const d = deferred()
          db.set @ token, d

          expire @ d.reject
          const remove = @=> db.delete(token)
          d.promise.then @ remove, remove
          return d.promise

        on_response(token, response) ::
          let d = db.get(token)
          if undefined === d ::
            d = db0.get(token)
            if undefined === d ::
              return
            db0.delete(token)
          else db.delete(token)

          d.resolve(response)


    bind_msg_api({anon, op_api}) ::
      return @{} __proto__: msg_api0, anon

        post(body) ::
          const parts = _pkts_.splitBody(body)
          if 1 < parts.length ::
            return this._msend(parts, this._mx_.opo0)

          const {id_route, id_target, opo0} = this._mx_
          const obj = @{} id_route, id_target, body: parts[0]
          const pkt = op_api.datagram @ obj, opo0
          this._send_pkt(pkt)

        send(body) ::
          const {response, opo} = this._new_response()

          const parts = _pkts_.splitBody(body)
          if 1 < parts.length ::
            return this._msend(parts, opo, response)

          const {id_route, id_target} = this._mx_
          const obj = @{} id_route, id_target, body: parts[0]
          const pkt = op_api.direct @ obj, opo
          this._send_pkt(pkt)
          return response


        stream() ::
          const {response, opo} = this._new_response()
          return this._wstream(opo, op_api.stream, response)

        multipart() ::
          const {response, opo} = this._new_response()
          return this._wstream(opo, op_api.multipart, response)

        _msend(parts, opo, response) ::
          return this._wstream(opo, op_api.multipart, response)
            .writeAll(parts, true)
            .response



  function bind_msg_api0() ::
    return @{} __proto__: null
      inspect() :: return `«${sym_sampi} ${this[sym_sampi]}»`
      toJSON(obj={}) :: obj[sym_sampi] = this[sym_sampi]; return obj

      _new_response() ::
        const {ctx, opo0} = this._mx_
        if opo0.msgid :: return @{} opo: opo0

        const token = ctx.newToken()
        return @{} token, response: ctx.responseFor(token)
          opo: Object.assign @ {token}, opo0

      _send_pkt(pkt) :: chan.send(pkt)

      _wstream(opo, op_method, response) ::
        const {id_route, id_target} = this._mx_
        let seq=0, self
        return self = @{} response
          write: body => ::
            const obj = @{} id_route, id_target, body
            const pkt = op_method @ obj,
              Object.assign({seq: seq++}, opo)
            this._send_pkt(pkt)
            return self

          writeAll: (body, close) => ::
            let cur, next
            for next of body ::
              if undefined !== cur ::
                self.write(cur)
              cur = next

            return undefined === cur ? self
              : close ? self.end(cur)
                : self.write(cur)

          end: body => ::
            seq = -seq
            self.write(body)
            seq = null
            return self

