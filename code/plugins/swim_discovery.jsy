const SWIM = require('swim')

const default_plugin_options = @{}
  swim_port: 2700
  swim_config: @{}
    interval: 100
    joinTimeout: 300
    pingTimeout: 30
    pingReqTimeout: 80
    pingReqGroupSize: 2

module.exports = exports = swim_plugin
export default swim_plugin
export function swim_plugin(plugin_options) ::
  plugin_options = Object.assign @ {}, default_plugin_options, plugin_options

  return function (hub) ::
    hub.createSWIM = createSWIM

    function assignSWIMMeta(meta, ...args) ::
      const {id_self: id_router, ec_pub_id} = hub.router
      const id_info = ec_pub_id 
        ? @{} id_router
              ec_pub_id: ec_pub_id.toString('base64')
        : @{} id_router

      return Object.assign @ {}, meta, ...args, id_info

    function createSWIM({host, meta, channel, swim_port}) ::
      let conn_info = 'function' === typeof channel 
        ? channel : channel.conn_info
      if conn_info ::
        const {ip_server, ip_local} = conn_info()
        channel = (ip_server || ip_local).asURL()
        if ! host ::
          if ! swim_port :: swim_port = plugin_options.swim_port
          host = `${(ip_server || ip_local).address}:${swim_port}`

      if ! host ::
        throw new Error @ `SWIM package requires a valid "host" parameter`

      meta = assignSWIMMeta @ meta, channel && @{} channel
      const swim_opts = Object.assign @
        {}, plugin_options.swim_config
        @: local: @{} host, meta

      const swim = new SWIM @ swim_opts
      return new SwimDiscovery @ swim

const swim_state_lut = @[] 'alive', 'suspect', 'dead'

export class SwimDiscovery ::
  constructor(swim) ::
    const byId = new Map()
    Object.defineProperties @ this, @:
      swim: @: value: swim
      byId: @: value: byId

    ::
      const {host, meta} = swim.opts.local
      this._on_updateEntry @ meta, 'self', host

    swim.on @ 'update', evt => ::
      this._on_updateEntry @
        evt.meta, swim_state_lut[evt.state], evt.host

  localhost() :: return this.swim.localhost()

  bootstrap(swim_hosts=[], swim_port) ::
    const swim = this.swim
    if 'string' === typeof swim_hosts ::
      dns.resolve @ swim_hosts, (err, hosts) => ::
        swim_hosts = hosts.map @ host => `${host}:${swim_port}`
        swim.bootstrap @ swim_hosts
      return this

    else if Array.isArray @ swim_hosts ::
      if swim_port ::
        swim_hosts = swim_hosts.map @ host => `${host}:${swim_port}`
      swim.bootstrap @ swim_hosts
      return this

    throw new TypeError @ `Unexpected 'swim_hosts' parameter format.`


  _on_updateEntry(meta, swim_state, swim_host) ::
    const {byId} = this, {id_router, ec_pub_id} = meta
    const cur = byId.get(id_router)
    if undefined !== cur && ec_pub_id != cur.ec_pub_id ::
      return // refuse to override existing entries with mismatched ec_pub_id

    const entry = Object.assign @ {}, meta, @{} swim_state, swim_host
    this.byId.set @ id_router, entry

