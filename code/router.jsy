import {FabricBase} from './utils.jsy'

export class FabricRouter extends FabricBase ::
  _createRoutesMap() :: return new Map()

  constructor() ::
    super()
    Object.defineProperties @ this, @{}
      routeDiscovery: @{} value: this._discoveryDefault.slice()

    this._bindDispatchRoutes()


  _bindDispatchRoutes() ::
    // as closures over private variables (routes_map)
    const hub_router = this
    const routes_map = this._createRoutesMap()
    const pqueue = this._promiseQueue()

    Object.defineProperties @ this, @:
      _bindDispatchRoutes: @{} value: false
      dispatch: @: value: dispatch
      resolveRoute: @: value: resolveRoute
      registerRoute: @{} value: registerRoute
      unregisterRoute: @{} value: unregisterRoute
    return dispatch


    function resolveRoute(id_route) ::
      return routes_map.get(id_route) ||
        hub_router.discoverRoute(id_route)

    async function dispatch_one(pkt, pktctx) ::
      try ::
        const id_route = pkt.id_route || ''
        let route = routes_map.get(id_route)
        if undefined === route ::
          route = await hub_router.discoverRoute(id_route, pktctx)
          if undefined === route ::
            // the route could have been registered during discovery
            route = routes_map.get(id_route)
          if undefined === route ::
            const channel = pktctx.channel
            return channel && channel.undeliverable(pkt, 'route')

        await route(pkt, pktctx)
      catch err ::
        hub_router._on_error @ 'router.dispatch', err, {pkt, pktctx}

    function dispatch(pktList, channel) ::
      const pq = pqueue() // pq will dispatch during Promise resolutions
      return pktList.map @ pkt =>
        pq.then @ () => dispatch_one @ pkt, {channel, hub_router}


    function registerRoute(id_route, route) ::
      if 'function' !== typeof route ::
        throw new TypeError @ `Expected 'route' to be a function`
      if routes_map.has @ id_route ::
        return routes_map.get(id_route)

      routes_map.set @ id_route, route
      return route
    function unregisterRoute(id_route) ::
      return routes_map.delete @ id_route


  registerPeerRoute(id_route, channel) ::
    return this.registerRoute @ id_route
      pkt => :: channel.send(pkt)


  async discoverRoute(id_route, pktctx) ::
    let lstDiscovery = this.routeDiscovery
    if 0 === lstDiscovery.length :: return

    const route = await this._discoverFirst @
      lstDiscovery.concat @# this._discoveryTimeout()
      @{} key: id_route, id_route, pktctx
      err => this._on_error @ 'router.discovery', err

    if null == route :: return
    if route.ephemeral :: return route

    if 'function' !== typeof route ::
      return this.registerPeerRoute(id_route, route)
    return this.registerRoute(id_route, route)


export default FabricRouter
