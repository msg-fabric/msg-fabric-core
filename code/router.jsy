import {FabricBase} from './utils.jsy'

export class FabricRouter extends FabricBase ::
  _createRoutesMap() :: return new Map()

  constructor() ::
    super()
    Object.defineProperties @ this, @{}
      routeDiscovery: @{} value: this._discoveryDefault.slice()

    this._bindDispatchRoutes()


  _bindDispatchRoutes() ::
    // as closures over private variables (targets map)
    const hub_router = this
    const routes = this._createRoutesMap()
    const pqueue = this._promiseQueue()

    Object.defineProperties @ this, @:
      _bindDispatchRoutes: @{} value: false
      dispatch: @: value: dispatch
      resolveRoute: @: value: resolveRoute
      registerRoute: @{} value: registerRoute
      unregisterRoute: @{} value: unregisterRoute
    return dispatch


    function resolveRoute(id_route) ::
      return routes.get(id_route) ||
        hub_router.discoverRoute(id_route)

    async function dispatch_one(pkt, pktctx) ::
      try ::
        const id_route = pkt.id_route
        let dispatch_route = routes.get(id_route)
        if undefined === dispatch_route ::
          dispatch_route = await hub_router.discoverRoute(id_route, pktctx)
          if undefined === dispatch_route ::
            const channel = pktctx.channel
            return channel && channel.undeliverable(pkt, 'route')

        await dispatch_route(pkt, pktctx)
      catch err ::
        hub_router._on_error @ 'router.dispatch', err, {pkt, pktctx}

    function dispatch(pktList, channel) ::
      const pq = pqueue() // pq will dispatch during Promise resolutions
      return pktList.map @ pkt =>
        pq.then @ () => dispatch_one @ pkt, {channel, hub_router}


    function registerRoute(id_route, dispatch_route) ::
      if 'function' !== typeof dispatch_route ::
        throw new TypeError @ `Expected 'dispatch_route' to be a function`
      if routes.has @ id_route :: return false

      routes.set @ id_route, dispatch_route
      return true
    function unregisterRoute(id_route) ::
      return routes.delete @ id_route


  registerPeerRoute(id_route, channel) ::
    return this.registerRoute @ id_route
      pkt => :: channel.send(pkt)


  async discoverRoute(id_route, pktctx) ::
    const route = await this._discoverFirst @
      this.routeDiscovery
      @{} key: id_route, id_route, pktctx
      err => this._on_error @ 'router.discovery', err

    if null == route :: return

    if ! route.ephemeral ::
      if 'function' === typeof route.send ::
        this.registerPeerRoute(id_route, route)
      else if 'function' === typeof route ::
        this.registerRoute(id_route, route)
    return route


export default FabricRouter
