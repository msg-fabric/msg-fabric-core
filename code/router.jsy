import {FabricBase} from './utils.jsy'

export class FabricRouter extends FabricBase ::
  _createRoutesMap() :: return new Map()

  constructor() ::
    super()
    Object.defineProperties @ this, @{}
      routeDiscovery: @{} value: []

    this._bindDispatchRoutes()


  _bindDispatchRoutes() ::
    // as closures over private variables (targets map)
    const hub_router = this
    const unregister = this.unregister
    const routes = this._createRoutesMap()
    const pqueue = this._promiseQueue()

    Object.defineProperties @ this, @:
      _bindDispatchRoutes: @{} value: false
      dispatch: @: value: dispatch
      resolveRoute: @: value: resolveRoute
      registerRoute: @{} value: registerRoute
      unregisterRoute: @{} value: unregisterRoute
    return dispatch


    function resolveRoute(id_route) ::
      return routes.get(id_route) ||
        hub_router.discoverRoute(id_route)

    async function dispatch_one(pkt, pktctx) ::
      try ::
        const id_route = pkt.id_route
        let dispatch_route = routes.get(id_route)
        if undefined === dispatch_route ::
          dispatch_route = await hub_router.discoverRoute(id_route)
          if undefined === dispatch_route ::
            const channel = pktctx.channel
            return channel && channel.undeliverable(pkt, 'route')

        if unregister === await dispatch_route(pkt, pktctx) ::
          hub_router.unregisterRoute(id_route)
      catch err ::
        hub_router._on_error @ 'router.dispatch', err, {pkt, pktctx}

    function dispatch(pktList, channel) ::
      const pq = pqueue() // pq will dispatch during Promise resolutions
      return pktList.map @ pkt =>
        pq.then @ () => dispatch_one @ pkt, {channel, hub_router}


    function registerRoute(id_route, dispatch_route) ::
      if 'function' !== typeof dispatch_route ::
        throw new TypeError @ `Expected 'dispatch_route' to be a function`
      if routes.has @ id_route :: return false

      routes.set @ id_route, dispatch_route
      return true
    function unregisterRoute(id_route) ::
      return routes.delete @ id_route


  registerPeerRoute(id_route, channel) ::
    return this.registerRoute @ id_route
      pkt => :: channel.send(pkt)


  async discoverRoute(id_route) ::
    const dispatch_route = await this._discoverFirst @
      {id_route}, this.routeDiscovery,
      err => this._on_error @ 'router.discovery', err

    if null != dispatch_route ::
      if ! dispatch_route.ephemeral ::
        this.registerRoute(id_route, dispatch_route)
      return dispatch_route


export default FabricRouter
