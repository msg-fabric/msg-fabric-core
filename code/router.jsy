import { o_assign, o_create, is_func } from './builtins.jsy'
import { discoverFirst, bindTimeouts } from './utils.jsy'
import { bindCoreRouterAPI } from './router_core.jsy'
import { base_channel, channel_kinds } from './channel.jsy'

export class FabricRouter ::
  constructor() ::
    o_assign @ this, @{}
      timeouts: bindTimeouts(),
      _channel_: @{} __proto__: base_channel, router: this
      routeDiscovery: (this.routeDiscovery || []).slice()
      public_routes: this._initPublicRoutes()

    const self = o_create(this)
    if this._skip_bind_api ::
      return self

    o_assign @ this,
      bindCoreRouterAPI @ self, this._initRoutes()
    return self

  _initRoutes() :: return new Map()
  _initPublicRoutes() :: return new Map()

  _on_error(scope, err) :: console.error @ 'router', scope, err

  async publishRoute(route) ::
    await route.ready
    const id_route = route.id_route
    if 'string' === typeof id_route ::
      this.public_routes.set @ id_route, route
      return route

  setUpstream(upstream) ::
    const disp = upstream.dispatch || upstream.send || upstream
    if is_func @ disp ::
      return this.upstream = disp

  upstreamRoute(id_route) ::
    return this.addDynamic @ id_route, this.upstream


  async discoverRoute(id_route) ::
    let lstDiscovery = this.routeDiscovery
    if 0 === lstDiscovery.length :: return

    const route = await discoverFirst @
      @{} key: id_route, kind: 'route'
      lstDiscovery, this

    if 'string' === typeof route ::
      const alias = this.getRoute(route)
      return alias ? alias
        : this.discoverRoute(route)

    return this.addDynamic @ id_route, route

  _discoveryTimeout(resolve) :: return this.timeouts(2000, resolve)
  _on_discovery_error(err) :: this._on_error @ 'router.discovery', err

  addPeer(id_route, channel, override) ::
    const disp = channel.dispatch || channel.send
    const res = this.addRoute @ id_route, disp, override
    if channel.when_closed ::
      channel.when_closed.then @ res[1]
    return res

  addDynamic(id_route, route) ::
    if 1 === arguments.length ::
      route = id_route.route || id_route
      id_route = id_route.id_route

    if null == route :: return
    if route.ephemeral :: return route

    const res = is_func(route)
      ? this.addRoute(id_route, route, true)
      : this.addPeer(id_route, route, true)

    return res[0]


  /* // from bindCoreRouterAPI

  addRoute(id_route, route, override) : route function
  removeRoute(id_route, route) : Boolean
  removeRoute(route function with id_route property) : Boolean

  hasRoute(id_route) : Boolean

  dispatch(pkt, channel) : Promise
  resolveRoute(id_route, allowDiscover, allowUpstream) : route function

  */


o_assign @ FabricRouter.prototype, channel_kinds,

export default FabricRouter

