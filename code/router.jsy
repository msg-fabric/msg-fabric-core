import {FabricBase} from './utils.jsy'

export class FabricRouter extends FabricBase ::
  _createRoutesMap() :: return new Map()

  constructor() ::
    super()
    Object.defineProperties @ this, @{}
      routeDiscovery: @{} value: []

    this.bindDispatchRoutes()


  bindDispatchRoutes() ::
    const routes = this._createRoutesMap()

    const resolveRoute = id_route =>
      routes.get(id_route) ||
        this.discoverRoute(id_route)

    const dispatch_one = async (pkt, channel) => ::
      try ::
        const id_route = pkt.id_route
        let dispatch_route = routes.get(id_route)
        if undefined === dispatch_route ::
          dispatch_route = await this.discoverRoute(id_route)
          if undefined === dispatch_route ::
            return channel && channel.undeliverable(pkt, 'route')

        if unregister === await dispatch_route(pkt, channel, this) ::
          this.unregisterRoute(id_route)
      catch err ::
        this._on_error @ 'router.dispatch', err, {pkt, channel}

    const pqueue = this._promiseQueue()
    function dispatch(pktList, channel) ::
      const pq = pqueue() // pq will dispatch during Promise resolutions
      return pktList.map @ pkt =>
        pq.then @ () => dispatch_one(pkt, channel)

    Object.defineProperties @ this, @:
      dispatch: @: value: dispatch
      resolveRoute: @: value: resolveRoute
      registerRoute: @{} value: registerRoute
      unregisterRoute: @{} value: unregisterRoute
    return dispatch


    // as closures over private routes map
    function registerRoute(id_route, dispatch_route) ::
      if 'function' !== typeof dispatch_route ::
        throw new TypeError @ `Expected 'dispatch_route' to be a function`
      if routes.has @ id_route :: return false

      routes.set @ id_route, dispatch_route
      return true
    function unregisterRoute(id_route) ::
      return routes.delete @ id_route


  registerPeerRoute(id_route, channel) ::
    return this.registerRoute @ id_route
      pkt => :: channel.send(pkt)


  async discoverRoute(id_route) ::
    const dispatch_route = await this._discoverFirst @
      id_route, this.routeDiscovery,
      err => this._on_error @ 'router.discovery', err

    if null != dispatch_route ::
      if ! dispatch_route.ephemeral ::
        this.registerRoute(id_route, dispatch_route)
      return dispatch_route


export default FabricRouter
