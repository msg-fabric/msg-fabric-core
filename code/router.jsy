import {createECDH, createHmac} from 'crypto'
import {pack_hello, pack_ping, dispControlByType as channelSetupByType} from './channel_setup'

try :: var ec_pem = require('ec-pem')
catch err ::

function initRouterIdentity(router, curve) ::
  // Create closures over the Router's EC private identity credentials
  var __ec_priv_id__, ec_pub_id, id_self
  while ! id_self :: // ensure id_self !== 0 by happenstance
    __ec_priv_id__ = Object.assign @ createECDH(curve), @{} curve
    ec_pub_id = __ec_priv_id__.generateKeys(null, 'compressed')
    id_self = ec_pub_id.readUInt32LE(8) // read id from offset 8 to 12

  Object.defineProperties @ router, @:
    id_self: @: value: id_self
    ec_pub_id: @: value: ec_pub_id
    ec_id_hmac: @: value: ec_id_hmac


  if undefined === ec_pem ::
    const ec_pem_missing = @: value() ::
      throw new Error @ `Requires optional [ec-pem][1] dependency.\n    [1]: https://www.npmjs.com/package/ec-pem`

    Object.defineProperties @ router, @: ec_id_sign: ec_pem_missing, ec_id_verify: ec_pem_missing

  else ::
    const ec_signed_id = ec_id_sign('sha256', ec_pub_id).sign()
    if ! ec_signed_id_verify(ec_pub_id, ec_signed_id) ::
      throw new Error @ `Asserted self-verify of ec_pub_id failed`

    Object.defineProperties @ router, @:
      ec_signed_id: @: value: ec_signed_id
      ec_id_sign: @: value: ec_id_sign
      ec_id_verify: @: value: ec_id_verify


  return id_self

  function ec_id_hmac(ec_pub_other, reverse) ::
    const secret = __ec_priv_id__.computeSecret(ec_pub_other)
    return createHmac('sha256', secret)
      .update @ reverse ? ec_pub_other : ec_pub_id
      .digest()

  function ec_id_sign(algorithm, ...args) ::
    return ec_pem.sign(__ec_priv_id__, algorithm, ...args)

  function ec_signed_id_verify(ec_pub_other, ec_signed_other) ::
    const verify = ec_id_verify(ec_pub_other, 'sha256', ec_pub_other)
    return ec_signed_other ? verify.verify(ec_signed_other) : verify

  function ec_id_verify(ec_pub_other, algorithm, ...args) ::
    // see ec-pem.verfiy and crypto.createVerfiy
    let ec = ec_pub_other
    if null == ec_pub_other.curve ::
      ec = Object.assign @ createECDH(curve), @{} curve
      if ec_pub_other.getPublicKey ::
        ec.setPublicKey @ ec_pub_other.getPublicKey()
      else ec.setPublicKey @ ec_pub_other

    return ec_pem.verify(ec, algorithm, ...args)


export class MessageRouter ::
  constructor() ::
    const id_self = initRouterIdentity(this, this.ec_curve)
    this.dispatch = this._initDispatch(id_self, this.routes)

  // --- Dispatch core ---

  _initDispatch(id_self, routes) ::
    routes.set @ 0, this.bindDispatchControl()
    routes.set @ id_self, this.bindDispatchSelf()
    const dispatch_one = this.bindDispatchRoute()

    const pqueue = this.promiseQueue()
    return (msgList, sendMsgRaw) => ::
      const pq = pqueue() // pq will dispatch during Promise resolutions
      return msgList.map @ msg =>
        pq.then @ () => dispatch_one(msg, sendMsgRaw)

  on_error_in_dispatch(err, msg) ::
    console.error @ 'Error during msg dispatch\n  msg:', msg, '\n', err, '\n'


  // --- Dispatch to route ---

  _routeDiscovery = []
  dispatch_discover_route(id_router, msg) ::
    const tip = Promise.resolve(id_router)
    return Promise.race @
      this._routeDiscovery.map @
        discover => tip.then @ discover

  bindDispatchRoute() ::
    return async (msg, sendMsgRaw) => ::
      try ::
        const id_router = msg.id_router
        let dispatch_route = this.routes.get(id_router)
        if undefined === dispatch_route ::
          dispatch_route = await this.dispatch_discover_route(id_router, msg)
          if null == dispatch_route :: return
          this.registerRoute(id_router, dispatch_route)

        if false === dispatch_route(msg, sendMsgRaw) ::
          this.unregisterRoute(id_router)
      catch err ::
        this.on_error_in_dispatch(err, msg, sendMsgRaw)


  routes = new Map()
  registerRoute(id_router, dispatch_route) ::
    if 'function' !== typeof dispatch_route ::
      if null != dispatch_route ::
        throw new TypeError @ `Expected 'dispatch_route' to be a function`
      else return false
    if this.routes.has @ id_router ::
      return false
    this.routes.set @ id_router, dispatch_route
    return true
  unregisterRoute(id_router) ::
    return this.routes.delete @ id_router

  imposterPeerRoute(id_router, sendMsgRaw) ::
  registerPeerRoute(id_router, sendMsgRaw) ::
    if 0 === id_router ::
      return false
    else if this.id_self === id_router ::
      return false
    return this.registerRoute @ id_router, msg => ::
      if 0 !== msg.ttl :: sendMsgRaw(msg)


  // --- Dispatch to local target

  dnu_dispatch_self(msg) ::
  bindDispatchSelf(msg) ::
    return async (msg, sendMsgRaw) => ::
      const id_target = msg.id_target
      let target = this.targets.get(id_target)
      if undefined === target ::
        target = await this.dnu_dispatch_self(msg)
        if null == target :: return

      if false === target(msg, this) ::
        this.unregisterTarget(id_target)

  targets = new Map()
  registerTarget(id_target, target) ::
    if 'function' !== typeof target ::
      throw new TypeError @ `Expected 'target' to be a function`
    if this.targets.has @ id_target ::
      return false
    return this.targets.set @ id_target, target
  unregisterTarget(id_target) ::
    return this.targets.delete @ id_target



  // --- Dispatch control messages

  bindDispatchControl() ::
    return (msg, sendMsgRaw) => ::
      const handler = this.dispControlByType[msg.type]
      if undefined !== handler ::
        handler(this, msg, sendMsgRaw)
      else
        this.dnu_dispatch_control(msg, sendMsgRaw)

  dispControlByType = Object.create @ this.dispControlByType
  dnu_dispatch_control(msg, sendMsgRaw) ::
    console.warn @ 'dnu_dispatch_control', msg.type, msg


  // --- Control message utilities

  sendRoutingHandshake(sendMsgRaw, ...args) ::
    return sendMsgRaw @ pack_hello(this.ec_pub_id), ...args
  sendPing(sendMsgRaw, ...args) ::
    return sendMsgRaw @ pack_ping(), ...args


MessageRouter.prototype.dispControlByType = Object.assign @ {}
  channelSetupByType

Object.assign @ MessageRouter.prototype, @{}
  ec_curve: 'prime256v1'
  promiseQueue
export default MessageRouter



function promiseQueue(nextPromise=() => Promise.resolve()) ::
  let tip = null
  return function () ::
    if null === tip ::
      tip = nextPromise()
      tip.then @ clear_tip
    return tip

  function clear_tip() ::
    tip = null

