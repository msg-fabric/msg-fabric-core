import data_utils from './data_utils.jsy'

const sym_dedup = Symbol('msg_fabric_discovery')
export function discoverFirst(lstFns, query, on_error) ::
  const key = query.key
  let dedup = lstFns[sym_dedup]
  if undefined !== dedup ::
    const res = dedup.get(key)
    if undefined !== res ::
      return res

  else ::
    dedup = new Map()
    Object.defineProperty @ lstFns, sym_dedup, {value: dedup}

  const res = new Promise @ resolve => ::
    const resolveIf = e => undefined !== e ? resolve(e) : e
    const tip = Promise.resolve(query)
    Promise.all @
      Array.from @ lstFns, fn =>
        tip.then(fn).then(resolveIf, on_error)
    .then @=> resolve(null)

  dedup.set @ key, res
  res.then @=> dedup.delete(key)
  return res


export function bindTimeouts(ms_interval) ::
  const q = []

  ms_interval = (0 | ms_interval) || 500

  ::
    const p0 = Promise.resolve(), p_then = p0.then.bind(p0)

    const tick = function () ::
      const tip = q.shift()
      if tip :: tip.forEach @ p_then

    const tid = setInterval @ tick, ms_interval
    if tid.unref :: tid.unref()


  add.resolve = (ms_min_timeout, value) =>
    new Promise @ y => add @ ms_min_timeout, @=> y @ value

  add.reject = (ms_min_timeout, value) =>
    new Promise @ (y, n) => add @ ms_min_timeout, @=> n @ value

  return add

  function add(ms_min_timeout, fn_timeout) ::
    if 'function' !== typeof fn_timeout :: throw new TypeError

    const idx = Math.max @ 1, Math.ceil @ (0|ms_min_timeout) / ms_interval
    const qi = q[idx] || []
    if 0 === qi.length :: q[idx] = qi
    qi.push @ fn_timeout



export const cmpPlugins = (a, b) => (0 | a && a.order) - (0 | b && b.order)
export function applyPlugins(key, pluginList, ...args) ::
  if ! key :: key = null
  for let plugin of pluginList ::
    if ! plugin :: continue
    if null !== key ::
      plugin = plugin[key]
    if 'function' === typeof plugin ::
      plugin(...args)


export class FabricBase ::

Object.assign @ FabricBase.prototype, @{}
  data_utils
  timeouts: bindTimeouts()
  _discoveryDefault: []
  _discoveryTimeout() :: return () => this.timeouts.resolve(5000, null)
  _on_error(scope, err) :: console.error @ scope, err

