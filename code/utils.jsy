import { o_defprop, is_func, as_func } from './builtins.jsy'
import data_utils from './data_utils.jsy'

const _discover_cache = new WeakMap()
export function discoverFirst(query, lstFns, host) ::
  let cache_belt = _discover_cache.get(lstFns)
  if undefined === cache_belt ::
    cache_belt = host._discoveryCache()
    _discover_cache.set(lstFns, cache_belt)

  const key = query.key
  for const cache of cache_belt ::
    const p = cache[key]
    if undefined !== p ::
      console.log @ "cache hit", @{} key, p
      return p

  const p = _discoverFirst(query, lstFns, host)
  cache_belt[0][key] = p
  return p

function _discoverFirst(query, lstFns, host) ::
  let p_search
  return p_search = new Promise @ async resolve => ::
    await null

    const ctx = @{} host, done: false, p_search
    const done = e => :: resolve(e || null); ctx.done = true

    const resolveFirst = async fn_discover => ::
      const e = await fn_discover(query, ctx)
      if undefined !== e :: done(e)

    host._discoveryTimeout(done)
    try ::
      for const p of Array.from @ lstFns, resolveFirst ::
        await p

      done(null)
    catch err ::
      host._on_error('discovery', err)


export function bindTimeouts(ms_interval) ::
  const p0 = Promise.resolve(), p_then = p0.then.bind(p0)
  const q = []

  tick_interval(ms_interval, q)
  add.interval = interval

  add.absent = (ms_min_timeout, callback, value) =>
    add @ ms_min_timeout, @=> callback @
      is_func(value) ? value() : value

  add.hashbelt = (ms_min_interval, max_length=4, create=Object) => ::
    interval @ ms_min_interval, @=> ::
      while max_length <= belt.length ::
        belt.pop()
      belt.unshift @ create()

    const belt = [create()]
    return belt
    
  return add.add = add


  function add(ms_min_timeout, callback) ::
    const idx = Math.max @ 1, Math.ceil @ (0|ms_min_timeout) / ms_interval
    const qi = q[idx] || []
    if 0 === qi.length :: q[idx] = qi
    qi.push @ as_func @ callback

  function interval(ms_min_interval, callback) ::
    as_func(callback)
    add @ ms_min_interval, function _wrap_() ::
      if false !== callback() ::
        add @ ms_min_interval, _wrap_

  function tick_interval(ms, lq) ::
    ms_interval = (0 | ms) || 250

    const tick = function () ::
      const tip = lq.shift()
      if tip :: tip.forEach @ p_then
      else if lq !== q && 0 === lq.length ::
        clearInterval(tid) // done

    const tid = setInterval @ tick, ms_interval
    if tid.unref :: tid.unref()

    add.changeInterval = ms => ::
      if ms_interval != ms ::
        // fork and finish current queue
        if 0 !== lq.length ::
          lq = lq.splice(0, lq.length)
        else clearInterval(tid)

        // start using new interval
        tick_interval(ms, q)

      return add



export const cmpPlugins = (a, b) => (0 | a && a.order) - (0 | b && b.order)
export function applyPlugins(key, pluginList, ...args) ::
  if ! key :: key = null
  for let plugin of pluginList ::
    if ! plugin :: continue
    if null !== key ::
      plugin = plugin[key]
    if is_func @ plugin ::
      plugin(...args)

