import { o_defprop } from './builtins.jsy'
import data_utils from './data_utils.jsy'

const sym_dedup = Symbol('msg_fabric_discovery')
export function discoverFirst(query, lstFns, host) ::
  const key = query.key
  let dedup = lstFns[sym_dedup]
  if undefined !== dedup ::
    const p_discover = dedup.get(key)
    if undefined !== p_discover ::
      return p_discover

  else ::
    dedup = new Map()
    o_defprop @ lstFns, sym_dedup, {value: dedup}


  const p_discover = _discoverFirst(query, lstFns, host)

  const clear = @=> dedup.delete(key)
  dedup.set @ key, p_discover
  p_discover.then(clear, clear)
  return p_discover

function _discoverFirst(query, lstFns, host) ::
  let p_discover
  return p_discover = new Promise @ resolve => ::
    const ans_null = () => resolve(null)
    host._discoveryTimeout(ans_null)

    const resolveFirst = async fn_discover => ::
      const e = await fn_discover @ await query, p_discover
      if undefined !== e ::
        resolve(e)

    Promise.all @
      Array.from @ lstFns, resolveFirst
    .then @ ans_null,
      err => host._on_error('discovery', err)



export function bindTimeouts(ms_interval) ::
  const p0 = Promise.resolve(), p_then = p0.then.bind(p0)
  const q = []

  tick_interval(ms_interval, q)

  add.resolve = (ms_min_timeout, value) =>
    new Promise @ resolve =>
      add @ ms_min_timeout, @=> resolve @ value

  add.reject = (ms_min_timeout, value) =>
    new Promise @ (resolve, reject) =>
      add @ ms_min_timeout, @=> reject @ value

  return add

  function add(ms_min_timeout, fn_timeout) ::
    if 'function' !== typeof fn_timeout :: throw new TypeError

    const idx = Math.max @ 1, Math.ceil @ (0|ms_min_timeout) / ms_interval
    const qi = q[idx] || []
    if 0 === qi.length :: q[idx] = qi
    qi.push @ fn_timeout

  function tick_interval(ms, lq) ::
    ms_interval = (0 | ms) || 250

    const tick = function () ::
      const tip = lq.shift()
      if tip :: tip.forEach @ p_then
      else if lq !== q && 0 === lq.length ::
        clearInterval(tid) // done

    const tid = setInterval @ tick, ms_interval
    if tid.unref :: tid.unref()

    add.interval = ms => ::
      if ms_interval != ms ::
        // fork and finish current queue
        if 0 !== lq.length ::
          lq = lq.splice(0, lq.length)
        else clearInterval(tid)

        // start using new interval
        tick_interval(ms, q)

      return add



export const cmpPlugins = (a, b) => (0 | a && a.order) - (0 | b && b.order)
export function applyPlugins(key, pluginList, ...args) ::
  if ! key :: key = null
  for let plugin of pluginList ::
    if ! plugin :: continue
    if null !== key ::
      plugin = plugin[key]
    if 'function' === typeof plugin ::
      plugin(...args)

