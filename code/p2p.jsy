import {timeoutResolve} from './utils.jsy'
import TargetRouter from './targets.jsy'

export class P2PRouter extends TargetRouter ::
  constructor(router) ::
    super('', router)

    this.public_routes = []
    Object.defineProperties @ this, @{}
      _queries: @{} value: this._createQueryMap()

    this.initP2P()

  _createQueryMap() :: return new Map()

  publishRoute(route) ::
    const id = route.id_route ? route.id_route
      : 'string' === typeof route ? route
      : null

    if ! id :: throw new Error @ 'Invalid route identifier'
    this.public_routes.push(id)
    return this


  initP2P() ::
    this.registerTarget @ 'hello', this._tgt_hello.bind(this)
    this.registerTarget @ 'olleh', this._tgt_olleh.bind(this)

  hello(hub, channel, timeout=1000) ::
    const req_id = hub.data_utils.random_base64(3)
    channel.send @ this.helloHandshake(req_id)

    const ans = new Promise @ (resolve, reject) => ::
      this._queries.set(req_id, resolve)
      timeoutResolve(timeout).then(reject)

    const cleanup = () => this._queries.delete(req_id)
    ans.then(cleanup, cleanup)
    return ans

  helloHandshake(req_id) ::
    return @{}
      id_target: 'hello', id_route: ''
      body: @{} req_id
        routes: this.public_routes

  _tgt_hello(pkt, pktctx) ::
    const {channel, hub_router} = pktctx
    const info = pkt.json()

    channel.send @:
      id_target: 'olleh', id_route: ''
      body: @{} req_id: info.req_id,
        routes: this.public_routes

    for const id_route of info.routes ::
      hub_router.registerPeerRoute @ id_route, channel

  _tgt_olleh(pkt, pktctx) ::
    const {channel, hub_router} = pktctx
    const info = pkt.json()
    for const id_route of info.routes ::
      hub_router.registerPeerRoute @ id_route, channel

    const resolve = this._queries.get(info.req_id)
    if undefined !== resolve ::
      delete info.req_id
      resolve(info)

export default P2PRouter
