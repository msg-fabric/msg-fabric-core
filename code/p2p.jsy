import {timeoutResolve} from './utils.jsy'
import TargetRouter from './targets.jsy'

export class P2PRouter extends TargetRouter ::
  constructor(router) ::
    super('', router)

    this.public_routes = []
    this.hello_body = {}
    Object.defineProperties @ this, @{}
      _queries: @{} value: this._createQueryMap()
      peerChannelDiscovery: @{} value: []

    this.initP2P()

  _createQueryMap() :: return new Map()

  publishRoute(route) ::
    if null == route :: return this
    const id = route.id_route ? route.id_route
      : 'string' === typeof route ? route
      : null

    if ! id :: throw new Error @ 'Invalid route identifier'
    this.public_routes.push(id)
    return this


  initP2P() ::
    this.registerTarget @ 'hello', this._tgt_hello.bind(this)
    this.registerTarget @ 'olleh', this._tgt_olleh.bind(this)

  hello(hub, channel, timeout=1000) ::
    const req_id = hub.data_utils.random_base64(3)
    channel.send @ this._helloHandshake('hello', req_id)

    const ans = new Promise @ (resolve, reject) => ::
      this._queries.set(req_id, resolve)
      timeoutResolve(timeout).then(reject)

    const cleanup = () => this._queries.delete(req_id)
    ans.then(cleanup, cleanup)
    return ans

  _helloHandshake(id_target, req_id) ::
    const body = Object.assign @ {}, this.hello_body,
      @{} req_id, routes: this.public_routes

    return @{} id_target, id_route: '', body

  _tgt_hello(pkt, pktctx) ::
    const info = pkt.json()
    pktctx.channel.send @
      this._helloHandshake('olleh', info.req_id)

    this._applyHelloInfo(info, pkt, pktctx)

  _tgt_olleh(pkt, pktctx) ::
    const info = pkt.json()

    this._applyHelloInfo(info, pkt, pktctx)

    const resolve = this._queries.get(info.req_id)
    if undefined !== resolve ::
      delete info.req_id
      resolve(info)

  _applyHelloInfo(info, pkt, pktctx) ::
    const {channel, hub_router} = pktctx

    const override = this.trustChannel(channel)
    for const id_route of info.routes ::
      if 'string' === typeof id_route ::
        hub_router.registerPeerRoute @ id_route, channel, override

    for const cb of this.peerChannelDiscovery || [] ::
      try :: cb(info, pkt, pktctx)
      catch err ::
        this._on_error @ 'peer_discovery_notification', err

  trustChannel(channel) :: return false

export default P2PRouter
