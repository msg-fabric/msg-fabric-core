import {timeoutResolve} from './utils.jsy'
import TargetRouter from './targets.jsy'

export class P2PRouter extends TargetRouter ::
  constructor(router, hub) ::
    super('', router)

    this.public_routes = []
    this.signed_routes = []
    this.hello_body = {}
    Object.defineProperties @ this, @{}
      _random_base64: @{} value: hub.data_utils.random_base64
      _queries: @{} value: this._createQueryMap()
      peerChannelDiscovery: @{} value: []
      verifyRouteAlgs: @{} value: {}

    this.initP2P()

  _createQueryMap() :: return new Map()

  publishRoute(route) ::
    if null == route :: return this
    const id = route.id_route ? route.id_route
      : 'string' === typeof route ? route
      : null

    if ! id :: throw new Error @ 'Invalid route identifier'
    this.public_routes.push(id)
    return this

  async publishSignedRoute(route) ::
    if 'function' !== typeof route.signRouteId ::
      throw new TypeError @ `Expected route with signRouteId()`

    await route.ready
    this.signed_routes[route.id_route] =
      (...args) => route.signRouteId(...args)

  registerVerifyRoute(alg, verify) ::
    if 'function' !== typeof verify ::
      throw new TypeError @ `Expected route with signRouteId()`
    this.verifyRouteAlgs[`alg::${alg}`] = verify


  initP2P() ::
    this.registerTarget @ 'hello', this._tgt_hello.bind(this)
    this.registerTarget @ 'olleh', this._tgt_olleh.bind(this)

  hello(channel, timeout=1000) ::
    const req_id = this._random_base64(3)
    Promise.resolve(channel).then @ channel =>
      channel.send @ this._helloHandshake @
        'hello', req_id

    const ans = new Promise @ (resolve, reject) => ::
      this._queries.set(req_id, resolve)
      timeoutResolve(timeout).then(reject)

    const cleanup = () => this._queries.delete(req_id)
    ans.then(cleanup, cleanup)
    return ans

  _helloHandshake(id_target, req_id, signed) ::
    const body = Object.assign @ {}, this.hello_body,
      @{} req_id, routes: this.public_routes, signed

    return @{} id_target, id_route: '', body

  async _tgt_hello(pkt, pktctx) ::
    const channel = pktctx.channel
    const info = pkt.json(), req_id = info.req_id

    channel.send @ this._helloHandshake @
      'olleh', req_id, await this._sign_routes(req_id, channel)

    await this._applyHelloInfo(info, pkt, pktctx)

  async _tgt_olleh(pkt, pktctx) ::
    const info = pkt.json()
    const resolve = this._queries.get(info.req_id)
    if undefined !== resolve ::
      await this._applyHelloInfo(info, pkt, pktctx)

      delete info.req_id
      resolve(info)

  async _applyHelloInfo(info, pkt, pktctx) ::
    if info.routes && this.allowUnsigned(pktctx.channel) ::
      this._applyUnsignedRoutes(info, pktctx)

    if info.signed ::
      await this._applySignedRoutes(info, pktctx)

    for const cb of this.peerChannelDiscovery || [] ::
      try :: cb(info, pkt, pktctx)
      catch err ::
        this._on_error @ 'peer_discovery_notification', err


  allowUnsigned(channel) :: return false !== channel.trusted
  trustChannel(channel) :: return true === channel.trusted

  _applyUnsignedRoutes(info, pktctx) ::
    const {channel, hub_router} = pktctx
    const override = this.trustChannel(channel)
    for const id_route of info.routes ::
      if 'string' === typeof id_route ::
        hub_router.registerPeerRoute @ id_route, channel, override


  async _applySignedRoutes(info, pktctx) ::
    const {channel, hub_router} = pktctx, {req_id} = info
    const verifyRouteAlgs = this.verifyRouteAlgs

    const q = []
    for const [id_route, rec] of info.signed ::
      const verify = verifyRouteAlgs[`alg::${rec.alg}`]
      if ! verify :: continue

      q.push @ 
        Promise.resolve @
          verify @ req_id, channel, id_route, rec
        .then @ valid => ! valid ? false : @
          hub_router.registerPeerRoute @ id_route, channel, true

      if q.length > 3 :: await Promise.all(q)

    await Promise.all(q)

  async _sign_routes(req_id, channel) ::
    const signed = []
    for const [id_route, signRouteId] of Object.entries(this.signed_routes) ::
      signed.push @# id_route, await signRouteId(req_id, channel)
    if signed.length :: return signed


export default P2PRouter
