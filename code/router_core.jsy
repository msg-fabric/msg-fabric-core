import { as_func } from './builtins.jsy'
import { bindXTargetAPI } from './xtgt_api.jsy'

export function bindCoreDispatchRouter(hub_router, hub, routes_map) ::
  // to create loopback, shim .dispatch onto a temporary prototype
  const loopback = ({ dispatch, __proto__: hub_router}).local_channel()

  const router_ctx = @{}
    hub, hub_router, timeouts: hub_router.timeouts,
    loopback, send: loopback.send
    to(id) :: return (...z) => this.send(id, ...z)

  const pktctx0 = @{} __proto__: router_ctx,
    // get send_direct() :: return this.channel.send
    redispatch: dispatch_one
    with_reply(id_reply) ::
      if id_reply ::
        this.reply = id_reply ? this.to(id_reply) : null
        this.done = this.with_reply
      else ::
        delete this.reply
        delete this.done
      return this


  return @{} dispatch, resolveRoute, loopback, router_ctx,
    ... bindXTargetAPI(router_ctx)


  function dispatch(pkt, channel) ::
    return dispatch_one @ pkt, @{} channel, pkt, __proto__: pktctx0

  async function dispatch_one(pkt, pktctx) ::
    pkt = await pkt
    if undefined === pkt || null === pkt :: return

    try ::
      let id_route = pkt[0] || ''
      let route = id_route
        ? routes_map.get(id_route)
        : (pktctx.channel || {}).peerRoute

      if undefined === route ::
        if pkt.bcast :: return // don't discover/warn on broadcast packet

        route = await resolveRoute(id_route, true, true)

        if undefined === route ::
          let channel = pktctx.channel
          return channel && channel.undeliverable(pkt, 'route')

      await route(pkt, pktctx)
    catch err ::
      hub_router._on_error @ 'dispatch', err, {pkt, pktctx}
    finally ::
      pktctx.channel = undefined // release channel referenece

  function _resolveRoute0(id_route) ::
    let idx, route = routes_map.get(id_route)
    // search for shared path routes based on '.' seperator
    while undefined === route && (-1 !== @ idx = id_route.lastIndexOf('.', idx)) ::
      route = routes_map.get @ id_route.slice(0, idx--)
    return route

  async function resolveRoute(id_route, allowDiscover, allowUpstream) ::
    let route = _resolveRoute0(id_route)
    if undefined !== route :: return route

    if allowDiscover ::
      await hub_router.discoverRoute(id_route, router_ctx)
      route = _resolveRoute0(id_route)
      if undefined !== route :: return route

    if allowUpstream ::
      // otherwise send upstream
      await hub_router.upstreamRoute(id_route)
      route = routes_map.get(id_route)

    return route


export function bindCoreRouterAPI(hub_router, hub, routes_map) ::
  // Allow individual queries but not enumeration
  let _use_override = {override: true}
  let _use_existing = {override: false}

  return @{}
    addRoute(id_route, route, opt) ::
      as_func(route)

      opt = true === opt ? _use_override
        : opt || _use_existing

      if ! opt.override && routes_map.has(id_route) ::
        return

      routes_map.set @ id_route, route
      let cancel = @=> this.removeRoute @ id_route, route

      if ! opt.ms_ttl ::
        return @{} route, cancel

      else ::
        let ttl = hub_router.timeouts.ttl @ opt.ms_ttl,
          opt.pre_cancel, cancel, opt.on_cancel
        ttl.route = false === opt.ttl_reset ? route
          : route = ttl.with_reset(route)
        return ttl

    removeRoute(id_route, route) ::
      if 1 === arguments.length ::
        route = id_route.route || id_route
        id_route = id_route.id_route || id_route[0]

      if null == route || route === routes_map.get(id_route) ::
        // remove only if route is currently at id_route
        return routes_map.delete @ id_route
      return false

    getRoute(id_route) ::
      return routes_map.get(id_route)

    hasRoute(id_route) ::
      return routes_map.has(id_route)

    ... bindCoreDispatchRouter @
          hub_router, hub, routes_map

