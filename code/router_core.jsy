import { o_assign, as_func } from './builtins.jsy'

export function bindCoreDispatchRouter(hub_router, routes_map) ::
  // as closures over private variables (routes_map)

  // to create loopback, shim .dispatch onto a temporary prototype
  const loopback = @
      @{} dispatch, __proto__: hub_router
    .local_channel()

  const pktctx0 = @{} __proto__: null,
    redispatch: dispatch_one
    hub_router, timeouts: hub_router.timeouts,
    loopback, send: loopback.send,
    get reply() :: return this.channel.send

  const router_ctx = @{} __proto__: null,
    hub_router, timeouts: hub_router.timeouts,
    loopback, send: loopback.send

  return @{} dispatch, resolveRoute, loopback, router_ctx

  function dispatch(pkt, channel) ::
    return dispatch_one @ pkt, @{} channel, __proto__: pktctx0

  async function dispatch_one(pkt, pktctx) ::
    try ::
      pkt = await pkt
      if undefined === pkt || null === pkt :: return

      const id_route = pkt.id_route || ''
      let route = id_route
        ? routes_map.get(id_route)
        : (pktctx.channel || {}).peerRoute

      if undefined === route ::
        route = await resolveRoute(id_route, true, true)

        if undefined === route ::
          const channel = pktctx.channel
          return channel && channel.undeliverable(pkt, 'route')

      await route(pkt, pktctx)
    catch err ::
      hub_router._on_error @ 'dispatch', err, {pkt, pktctx}

  function _resolveRoute0(id_route) ::
    let route = routes_map.get(id_route)
    if undefined !== route :: return route

    let idx
    while -1 !== @ idx = id_route.lastIndexOf('.', idx) ::
      route = routes_map.get @
        id_route.slice(0, idx)

      if undefined !== route ::
        return route

  async function resolveRoute(id_route, allowDiscover, allowUpstream) ::
    let route = _resolveRoute0(id_route)
    if undefined === route ::

      if allowDiscover ::
        route = await hub_router.discoverRoute(id_route)

        if undefined === route ::
          // the route could have been added during discovery
          route = _resolveRoute0(id_route)

          if undefined === route && allowUpstream ::
            // otherwise just send upstream
            route = await hub_router.upstreamRoute(id_route)

    return route


export function bindCoreRouterAPI(hub_router, routes_map) ::
  // Allow individual queries but not enumeration
  const router_api = @{}
    addRoute(id_route, route, override) ::
      as_func(route)
      if ! override && routes_map.has(id_route) ::
        return routes_map.get(id_route)

      routes_map.set @ id_route, route
      return @[] route, @=> this.removeRoute @ id_route, route

    removeRoute(id_route, route) ::
      if 1 === arguments.length ::
        route = id_route.route || id_route
        id_route = id_route.id_route

      if null == route || route === routes_map.get(id_route) ::
        // remove only if route is currently at id_route
        return routes_map.delete @ id_route
      return false

    getRoute(id_route) ::
      return routes_map.get(id_route)

    hasRoute(id_route) ::
      return routes_map.has(id_route)

  return o_assign @ router_api,
    bindCoreDispatchRouter @
      hub_router, routes_map
