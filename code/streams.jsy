
export function bindDispatchMsgRaw(api_internal) ::
  const dispatch = api_internal.router.dispatch
  dispatchMsgRaw.api = Object.defineProperties @ api_internal, @:
    sendRaw: @: value: dispatchMsgRaw
  return dispatchMsgRaw

  function dispatchMsgRaw(msg, asPromise) ::
    dispatch @ [msg], dispatchMsgRaw
    if asPromise :: return Promise.resolve()


export function bindStreamSendMsgRaw(stream, api_channel, props) ::
  sendMsgRaw.api = Object.create @ api_channel
    Object.assign @ {}, props
      @: sendRaw: @: value: sendMsgRaw

  connectPacketStream @ stream, sendMsgRaw, true
  return sendMsgRaw

  function sendMsgRaw(msg, asPromise) ::
    if ! Buffer.isBuffer @ msg ::
      if ! Buffer.isBuffer @ msg._raw_ ::
        throw new TypeError @ `sendMsgRaw expected 'msg' as a Buffer or an object with a '_raw_' Buffer`
      msg = msg._raw_

    if null === msg ::
      return void stream.end()
    if ! asPromise ::
      return void stream.write(msg)
    return new Promise @ function (resolve, reject) ::
      stream.write @ msg, err => err ? reject(err) : resolve()


export function bindSocketSendMsgRaw(sock, api_channel, asURL) ::
  sock.setNoDelay(true).setKeepAlive(true)

  const conn_info = () => @:
    ip_remote: @{} asURL, address: sock.remoteAddress, port: sock.remotePort
    ip_local: @{} asURL, address: sock.localAddress, port: sock.localPort

  return bindStreamSendMsgRaw @ sock, api_channel
    @: conn_info: @: value: conn_info


export function connectPacketStream(stream, sendMsgRaw, endStreamOnShutdown) ::
  return sendMsgRaw.shutdown = new Promise @ (resolve, reject) => ::
    const hub = sendMsgRaw.api.hub, dispatch = hub.router.dispatch

    let pktParser = hub._packetStream.clone()
    const on_recv_messages = msgList =>
      dispatch @ msgList, sendMsgRaw


    stream.on @ 'error', shutdown
    stream.on @ 'close', shutdown
    stream.on @ 'data', function (data) ::
      try ::
        var msgList = pktParser.feed @ data
        if 0 < msgList.length ::
          on_recv_messages(msgList)
      catch err ::
        return shutdown(err)

    function shutdown(err) ::
      if undefined === pktParser :: return
      pktParser = undefined
      if endStreamOnShutdown ::
        stream.end()

      err ? reject(err) : resolve()

