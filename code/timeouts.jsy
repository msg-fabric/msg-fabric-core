import { o_assign, o_defprop, is_func, as_func, _unref } from './builtins.jsy'

import { ao_defer_v } from 'roap'
export { ao_defer_v, ao_fence_v, ao_push_stream } from 'roap'


const timeout_ttl_base = @{}
  extend: false
  reset() :: this.extend = true; return this
  with_reset(fn) :: return (...args) => @ this.reset(), fn(...args)
  bind_cleanup(cleanup_fns) ::
    return async cancel => ::
      try ::
        for const cleanup of cleanup_fns ::
          if cleanup && ! this.extend ::
            await cleanup(this)

      finally ::
        if ! this.extend ::
          await cancel()

        this.extend = false


export function bindTimeouts(ms_interval) ::
  const q=[]

  tick_interval(ms_interval, q)
  return o_assign @ add, @{}
    add, interval

    race(ms_min_timeout, ...promises) ::
      let dp = ao_defer_v()
      promises.push(dp[0])
      add(ms_min_timeout, dp[1])
      return Promise.race(promises)

    absent: (ms_min_timeout, callback, value) =>
      add @ ms_min_timeout, @=> callback @
        is_func(value) ? value() : value

    hashbelt: (ms_min_interval, max_length=4, create=Object) => ::
      interval @ ms_min_interval, @=> ::
        while max_length <= belt.length ::
          belt.pop()
        belt.unshift @ create()

      const belt = [create()]
      return belt

    ttl(ms_min_interval, ... cleanup_fns) ::
      const ttl = @{} __proto__: timeout_ttl_base
      ttl.cancel = interval @ ms_min_interval || 60000, ttl.bind_cleanup(cleanup_fns)
      return ttl

    _on_error(err) :: console.error(err)


  function add(ms_min_timeout, callback) ::
    if callback ::
      let idx = Math.max @ 1, Math.ceil @ (0|ms_min_timeout) / ms_interval
      let qi = q[idx] || []
      if 0 === qi.length :: q[idx] = qi
      qi.push @ as_func @ callback


  function interval(ms_min_interval, callback) ::
    as_func(callback)
    let cancel = @:: interval = null
    let interval = @::
      if null !== interval ::
        callback(cancel)
        add @ ms_min_interval, interval

    add @ ms_min_interval, interval
    return cancel


  function tick_interval(ms, lq) ::
    ms_interval = (0 | ms) || 67

    function tick() ::
      const tip = lq.shift()
      if tip ::
        let p0=Promise.resolve(add)
        for let fn of tip ::
          p0.then(fn).catch(add._on_error)

      else if lq !== q && 0 === lq.length ::
        clearInterval(tid) // done

    const tid = setInterval @ tick, ms_interval
    _unref(tid)

    add.changeInterval = ms => ::
      if ms_interval != ms ::
        // fork and finish current queue
        if 0 !== lq.length ::
          lq = lq.splice(0, lq.length)
        else clearInterval(tid)

        // start using new interval
        tick_interval(ms, q)

      return add

