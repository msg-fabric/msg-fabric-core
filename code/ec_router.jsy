import {createECDH, createHmac} from 'crypto'
import MessageRouter from './router'

try :: var ec_pem = require('ec-pem')
catch err ::


export class ECMessageRouter extends MessageRouter ::
  constructor() ::
    super()
    initRouterIdentity(this, this.ec_curve || 'prime256v1')
    this._initDispatch()

export default ECMessageRouter


function initRouterIdentity(router, curve) ::
  // Create closures over the Router's EC private identity credentials
  var __ec_priv_id__, ec_pub_id, id_self
  while ! id_self :: // ensure id_self !== 0 by happenstance
    __ec_priv_id__ = Object.assign @ createECDH(curve), @{} curve
    ec_pub_id = __ec_priv_id__.generateKeys(null, 'compressed')
    id_self = ec_pub_id.readUInt32LE(8) // read id from offset 8 to 12

  Object.defineProperties @ router, @:
    id_self: @: value: id_self
    ec_pub_id: @: value: ec_pub_id
    ec_id_hmac: @: value: ec_id_hmac


  if undefined === ec_pem ::
    const ec_pem_missing = @: value() ::
      throw new Error @ `Requires optional [ec-pem][1] dependency.\n    [1]: https://www.npmjs.com/package/ec-pem`

    Object.defineProperties @ router, @: ec_id_sign: ec_pem_missing, ec_id_verify: ec_pem_missing

  else ::
    const ec_signed_id = ec_id_sign('sha256', ec_pub_id).sign()
    if ! ec_signed_id_verify(ec_pub_id, ec_signed_id) ::
      throw new Error @ `Asserted self-verify of ec_pub_id failed`

    Object.defineProperties @ router, @:
      ec_signed_id: @: value: ec_signed_id
      ec_id_sign: @: value: ec_id_sign
      ec_id_verify: @: value: ec_id_verify

  return id_self

  function ec_id_hmac(ec_pub_other, reverse) ::
    const secret = __ec_priv_id__.computeSecret(ec_pub_other)
    return createHmac('sha256', secret)
      .update @ reverse ? ec_pub_other : ec_pub_id
      .digest()

  function ec_id_sign(algorithm, ...args) ::
    return ec_pem.sign(__ec_priv_id__, algorithm, ...args)

  function ec_signed_id_verify(ec_pub_other, ec_signed_other) ::
    const verify = ec_id_verify(ec_pub_other, 'sha256', ec_pub_other)
    return ec_signed_other ? verify.verify(ec_signed_other) : verify

  function ec_id_verify(ec_pub_other, algorithm, ...args) ::
    // see ec-pem.verfiy and crypto.createVerfiy
    let ec = ec_pub_other
    if null == ec_pub_other.curve ::
      ec = Object.assign @ createECDH(curve), @{} curve
      if ec_pub_other.getPublicKey ::
        ec.setPublicKey @ ec_pub_other.getPublicKey()
      else ec.setPublicKey @ ec_pub_other

    return ec_pem.verify(ec, algorithm, ...args)

