import { o_assign, o_create  } from './builtins.jsy'
import { ao_fence_sink, ao_feeder_v } from 'roap'
import { DiscoveryBase } from './discovery.jsy'
import { bindCoreTargetAPI } from './targets_core.jsy'

export class TargetRouter extends DiscoveryBase ::

  constructor(id_route, router, hub) ::
    super()
    let {randId} = hub, {timeouts, send, loopback} = router.router_ctx
    o_assign @ this, @{} timeouts, send, loopback, randId

    if this._skip_bind_api :: return this

    let self = o_create(this)
    o_assign @ this,
      bindCoreTargetAPI @ self, this._initTargets(), id_route, router
    return self

  _initTargets() :: return new Map()
  _on_error(scope, err) :: console.error @ 'target', scope, err
  _on_stream_error(err) :: console.error @ 'stream target', err

  newTargetId() :: return this.randId(4)

  async discoverTarget(id_target, rtrctx) ::
    await this._discoverFirst @:
      key: id_target, id_target, kind: 'target', rtrctx


  /* // from bindCoreTargetAPI

  ready : Promise<Boolean>

  addTarget(id_target, target, opt) : {id_target, id_route}
  removeTarget(id_target) : Boolean
  removeTarget({id_target}) : Boolean

  getTarget(id_target) : function(pkt, pktctx)
  hasTarget(id_target) : Boolean

  xresp(id_target) : target management object
  xtgt(id_target) : target management object

  */

  addReply(...args) :: return this.xresp().with(...args)

  addStream(id_target, opt) ::
    let f_out = ao_fence_sink()
    f_out.id = this.addTarget(id_target, ao_feeder_v(f_out), opt)
    return f_out

  addStreamTarget(id_target, async_target, opt) ::
    let f_out = this.addStream(id_target, opt)

    // async_target(stream, target_router) : promise
    // where stream is an async generator -- for await [pkt, ctx] of stream
    ;(f_out.when_run = async_target(f_out, this))
      .catch(opt && opt.on_error || this._on_stream_error)
    return f_out.id

