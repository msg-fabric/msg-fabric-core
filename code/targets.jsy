import { o_assign, o_create } from './builtins.jsy'
import { random_base64 } from './data_utils.jsy'
import { discoverFirst } from './utils.jsy'
import { bindCoreTargetAPI } from './targets_core.jsy'

export class TargetRouter ::

  constructor(id_route, router, hub) ::
    o_assign @ this, @{}
      targetDiscovery: (this.targetDiscovery || []).slice()
      timeouts: router.timeouts

    if this._skip_bind_api :: return this

    const self = o_create(this)
    o_assign @ this,
      bindCoreTargetAPI @ self, this._initTargets(), id_route, router
    return self

  _initTargets() :: return new Map()
  _on_error(scope, err) :: console.error @ 'target', scope, err

  newTargetId() :: return random_base64(6)
  createTarget(target) ::
    return this.addTarget(this.newTargetId(), target)


  async discoverTarget(id_target, pktctx) ::
    let lstDiscovery = this.targetDiscovery
    if 0 === lstDiscovery.length :: return

    const target = await discoverFirst @
      @{} key: id_target, id_target, pktctx
      lstDiscovery, this

    if null == target :: return

    if ! target.ephemeral ::
      this.addTarget(id_target, target)
    return target

  _discoveryTimeout(resolve) :: return this.timeouts(2000, resolve)

  /* // from bindCoreTargetAPI

  ready : Promise<Boolean>

  addTarget(id_target, target, override) : {id_target, id_route}
  addTarget({id_target, target, override}) : {id_target, id_route}
  addTarget(target function with id_target property) : {id_target, id_route}

  removeTarget(id_target) : Boolean
  removeTarget({id_target}) : Boolean
  removeTarget(target function with id_target property) : Boolean

  hasTarget(id_target) : Boolean

  addReply(ms_timeout=1000, as_full_pkt) : Promise with id={id_target, id_route}

  */

  addReply(ms_timeout=1000, absent) ::
    const tgt = this.transient()
    const p = new Promise @ (resolve, reject) => ::
      tgt.enable @ pkt => ::
        tgt.disable()
        resolve @ pkt.body

      if ms_timeout ::
        tgt.timeouts @ ms_timeout, @=> ::
          tgt.disable()
          resolve @ 'function' === typeof absent
            ? p.then(absent) : absent

    p.catch @ Boolean // supress 'unhandled rejection' warnings
    return o_assign @ p, tgt


  async addEndpoint(initialize) ::
    const tgt = this.transient()
    const target = await initialize(tgt)

    if 'function' === typeof target ::
      tgt.target = target
      tgt.enable()

    else if ! tgt.target && false !== target ::
      throw new TypeError @ 'Endpoint initialize must return a function or false'

    return tgt.id

export default TargetRouter

