
const _answers = new Map()
let _g_mid = 100
function awaitAnswer() ::
  const mid = _g_mid++
  const p = new Promise @ (resolve, reject) => ::
    _answers.set @ mid, @{} resolve, reject
  p.mid = mid
  return p

function routeAnswer(mid, ans) ::
  mid = mid.mid || mid
  const r = _answers.get @ mid
  _answers.delete @ mid
  if r :: return r.resolve @ ans

export const basic_p2p = @{}
  __proto__: null

  async hello(mid) ::
    const ans = mid ? null : awaitAnswer()
    await this.channel.send @:
      id_target: ans ? 'hello' : 'olleh'
      mid: ans ? ans.mid : mid
      body: @{}
        version: 'basic'
        routes: Array.from @
          this.router.public_routes.keys()
    return ans

  peerRoute(pkt, pktctx) ::
    if 'basic' !== pkt.body.version :: return

    const { router, channel } = this
    for const id_route of pkt.body.routes || [] ::
      router.addPeer @ id_route, channel, false

    switch pkt.id_target ::
      case 'hello': return this.hello @ pkt.mid
      case 'olleh': return routeAnswer @ pkt.mid, pkt.body

