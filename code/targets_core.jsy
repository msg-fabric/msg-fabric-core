import { o_assign, o_defprop, as_func, p_then } from './builtins.jsy'

export function bindCoreDispatchTarget(tgt_router, targets_map, id_route, router) ::
  // as closures over private variables (targets_map)
  return @{} ready: _add_target_route(id_route)

  async function target_route(pkt, pktctx) ::
    let id_target = pkt[1] || ''
    let target = targets_map.get(id_target)

    if undefined === target ::
      await tgt_router.discoverTarget(id_target, pktctx)
      target = targets_map.get(id_target)

      if undefined === target ::
        let channel = pktctx.channel
        return channel && channel.undeliverable(pkt, 'target')

    // Trigger on_sent for internal hub routing
    p_then(pkt.on_sent, pkt)

    pktctx.tgt_router = tgt_router
    await target(pkt, pktctx)


  async function _add_target_route(id_route) ::
    if 'string' !== typeof id_route ::
      id_route = await id_route
    tgt_router.id_route = target_route.id_route = id_route
    router.addRoute @ id_route, target_route, true
    return true


export function bindCoreTargetAPI(tgt_router, targets_map, id_route, router) ::
  const xtgt_api = @{} tgt_router, __proto__: router.xtgt_api
  const xresp_api = @{} tgt_router, __proto__: router.xresp_api

  function setTarget(id_target, target) ::
    targets_map.set @ id_target, as_func(target)

  return @{}
    setTarget
    addTarget(id_target, target, opt) ::
      let id = @[] id_route, id_target
      if !opt || !opt.ms_ttl ::
        setTarget @ id_target, target
        return id

      let cancel = @=> this.removeTarget @ id_target, target
      let ttl = router.timeouts.ttl @ opt.ms_ttl,
        opt.pre_cancel, cancel, opt.on_cancel
      setTarget @ id_target,
        false === opt.ttl_reset ? target
          : target = ttl.with_reset(target)
      ttl.id = id
      return ttl

    getTarget: id_target => targets_map.get(id_target)
    hasTarget: id_target => targets_map.has(id_target)
    removeTarget: id_target => targets_map.delete(id_target[1] || id_target)
    cancelTarget(id_target, target) ::
      if undefined === target ::
        target = targets_map.get(id_target)
      return @=> target === targets_map.get(id_target)
        ? targets_map.delete(id_target) : null


    asId(id_target) :: return @[] id_route, id_target || this.newTargetId()
    xresp(id_target) :: return @{} id: this.asId(id_target), __proto__: xresp_api
    xtgt(id_target) :: return @{} id: this.asId(id_target), __proto__: xtgt_api

    ... bindCoreDispatchTarget @
          tgt_router, targets_map,
          id_route, router

