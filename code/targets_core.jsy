import { o_assign, o_defprop, as_func } from './builtins.jsy'
import { bindXTargetAPI } from './xtgt_api.jsy'

export function bindCoreDispatchTarget(tgt_router, targets_map, id_route, router) ::
  // as closures over private variables (targets_map)
  const ready = 'string' === typeof id_route
    ? Promise.resolve @ addRoute @ id_route
    : id_route.then @ addRoute

  return @{} ready

  async function target_route(pkt, pktctx) ::
    const id_target = pkt[1] || ''
    let target = targets_map.get(id_target)

    if undefined === target ::
      target = await tgt_router.discoverTarget(id_target, pktctx)

      if undefined === target ::
        // the target could have been added during discovery
        target = targets_map.get(id_target)

      if undefined === target ::
        const channel = pktctx.channel
        return channel && channel.undeliverable(pkt, 'target')

    // Trigger on_sent for internal hub routing
    if undefined !== pkt.on_sent ::
      Promise.resolve().then(pkt.on_sent)

    pktctx.tgt_router = tgt_router
    await target(pkt, pktctx)


  function addRoute(id_route) ::
    o_defprop @ tgt_router, @{}
      id_route: @{} value: id_route, enumerable: true

    target_route.id_route = id_route
    router.addRoute @ id_route, target_route, true
    return true


export function bindCoreTargetAPI(tgt_router, targets_map, id_route, router) ::
  const [xtgt_api, reply_xtgt_api] = bindXTargetAPI @
    tgt_router, targets_map, id_route, router

  const targets_api = @{}
    __proto__: null,

    addTarget(id_target, target) ::
      targets_map.set @ id_target, as_func(target)
      return @[] id_target, id_route

    removeTarget(id_target) ::
      return targets_map.delete @ id_target[1] || id_target

    getTarget(id_target) :: return targets_map.get(id_target)
    hasTarget(id_target) :: return targets_map.has(id_target)

    xtgt(as_reply, id_target) ::
      if ! id_target ::
        id_target = this.newTargetId()
      return @{}
        __proto__: as_reply ? reply_xtgt_api : xtgt_api
        id: @[] id_route, id_target
        disable() :: targets_map.delete(id_target)


  return o_assign @ targets_api,
    bindCoreDispatchTarget @
      tgt_router, targets_map,
      id_route, router

