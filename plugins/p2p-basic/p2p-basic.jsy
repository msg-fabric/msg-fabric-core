export function p2p_plugin({ p2p }={}) ::
  return hub => ::
    hub._root_.p2p = p2p || bind_basic_p2p(hub)


export function bind_basic_p2p(hub) ::
  return @{}
    initForChannel(channel) ::
      return Object.create @ this, @{}
        channel: @{} value: channel
        router: @{} value: channel.router

    async hello(ms_timeout=500) ::
      let { channel, router } = this
      let id_reply = hub.randId(6)
      let dp = router.timeouts.ao_defer_v()
      this[ '_m$_' + id_reply ] = dp[1]
      if ms_timeout ::
        router.timeouts @ ms_timeout, dp[1]

      await channel.send @ '', 'hello', @{}
        version: 'basic', id_reply, ts: new Date

      let ans
      try :: ans = await dp[0]
      finally ::
        delete this[ '_m$_' + id_reply ]

      let { public_routes } = router
      for let id_route of Object(ans).routes || [] ::
        // Keep local public routes local
        if ! public_routes.get(id_route) ::
          channel.addRoute @ id_route, false

      return ans

    peerRoute(pkt) ::
      let {1: id_target, body} = pkt
      let fn = this[ '_m$_' + id_target ]
      return fn ? fn.call(this, body) : null

    _m$_hello(body) ::
      let {version, id_reply} = Object(body)
      if 'basic' !== version :: return
      if ! id_reply :: return

      return this.channel.send @ '', id_reply, @{}
        version, ts: new Date
        routes: Array.from @
          this.router.public_routes.keys()

