
export default p2p_plugin
export function p2p_plugin({ p2p }={}) ::
  return hub => ::
    if undefined === p2p ::
      p2p = bind_basic_p2p @ hub.data_utils

    hub.p2p = p2p


export function bind_basic_p2p({ random_base64 }) ::

  const basic_hello_body = (router, id_reply) => @:
    version: 'basic', id_reply, ts: new Date,
    routes: Array.from @ router.public_routes.keys()

  return @{}
    __proto__: null

    async hello(ms_timeout=500) ::
      const id_reply = random_base64(6)
      const k = '_m$_' + id_reply

      const p = new Promise @ (resolve, reject) => ::
        this[k] = resolve
        if ms_timeout ::
          this.router.timeouts @ ms_timeout, reject

      const clear = @=> :: delete this[k]
      p.then(clear, clear)

      await this.channel.send @ '', 'hello',
        basic_hello_body @ this.router, id_reply

      return p

    peerRoute(pkt) ::
      const {id_target, body} = pkt
      if 'basic' !== body.version :: return

      const { router, channel } = this
      for const id_route of body.routes || [] ::
        router.addPeer @ id_route, channel, false


      if 'hello' === id_target ::
        this.channel.send @ '', body.id_reply, 
          basic_hello_body @ router

      else ::
        const fn = this[ '_m$_' + id_target ]
        if fn :: return fn.call(this, body)

