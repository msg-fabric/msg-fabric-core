import {is_json_body, json_stringify, json_parse} from './common_base.jsy'
import {as_hdr, as_pkt0} from './common_base.jsy'

export const PktBase = @{}
  __proto__: null, is_pkt: true
  toJSON() :: throw new Error @ 'Packets are not for serializing'
  get id_route() :: return this._hdr_[0]
  get id_target() :: return this._hdr_[1]
  meta(reviver) :: return json_parse(this._meta_||null, reviver)

  inspect() :: return this._hdr_
    ? `«pkt(${this.pkt_kind}) ${json_stringify(this._hdr_.join(' '))}»`
    : `«{Pkt(${this.pkt_kind})}»`
  repack_pkt(repack) :: return repack(this, this.pkt_kind)


export function json(reviver) ::
  const src = this.text()
  if src :: return json_parse(src, reviver)

export const PktJsonBase = @{} __proto__: PktBase
  pkt_kind: 'json', is_pkt_json: true
  text() :: return this._body_
  json // and... buffer(){}  base64(){}

export const PktDataBase = @{} __proto__: PktBase
  pkt_kind: 'data', is_pkt_data: true
  json // and... text(){}  buffer(){}  base64(){}


export const sym_split = Symbol('pkt split')
export const k_data = '=', k_split_data = '?'
export const k_json = '@', k_split_json = '#'

export const PktSplitJson = @{} __proto__: PktBase
  pkt_kind: 'split_json', is_pkt_split: true

export const PktSplitData = @{} __proto__: PktBase
  pkt_kind: 'split_data', is_pkt_split: true

export const PktSplitData64 = @{} __proto__: PktBase
  pkt_kind: 'split_b64', is_pkt_split: true


export function bind_packObjPacket({PktData, PktJson, packBody}, repack) ::
  const pktByKind = @{}
    [k_data]: PktData, [k_split_data]: PktSplitData
    [k_json]: PktJson, [k_split_json]: PktSplitJson

  return function fromObjBinaryPacket(obj) ::
    if 'function' === typeof obj.repack_pkt ::
      return obj.repack_pkt(repack)

    const hdr=as_hdr(obj), {body, meta, on_sent}=obj
    const k_token = null!=body ? body[sym_split] : undefined
    const pkt = undefined !== k_token
      ? @ undefined !== body.src
          ? as_pkt0 @ hdr, meta, body.src, pktByKind[k_token]
          : as_pkt0 @ hdr, meta, body.buf, pktByKind[k_token]

      : @ is_json_body(body)
          ? as_pkt0 @ hdr, json_stringify(meta)||'', json_stringify(body)||'', PktJson
          : as_pkt0 @ hdr, json_stringify(meta)||'', packBody(body), PktData

    // Pass on on_sent for backpressure signaling
    if undefined !== on_sent :: pkt.on_sent = on_sent
    return pkt

export function bind_unpackStringPacket(pktByKind) ::
  return function unpackStrPacket(pkt_str) ::
    const i1 = pkt_str.indexOf('\t', 0)
    const i2 = pkt_str.indexOf('\t', 1+i1)
    if -1 === i1 || -1 === i2 ::
      throw new Error @ 'Invalid packet'

    const hdr = pkt_str.slice(0, i1)
    const kind = pkt_str[1+i1]
    const meta = pkt_str.slice(2+i1, i2)
    const body = pkt_str.slice(1+i2)

    return as_pkt0 @ hdr, meta, body, pktByKind[kind]
