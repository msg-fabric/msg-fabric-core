export const json_parse = JSON.parse
export const json_stringify = JSON.stringify

// Max of 16,384 bytes is the practical SCTP limit. (ref: https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Using_data_channels#Concerns_with_large_messages)
export const maxlen_pkt = 16 << 10
export const maxlen_hdr = 256 // 192 bytes id_route + id_target; 56 all op fields; 8 bytes spacing overhead
export const maxlen_msg = maxlen_pkt - maxlen_hdr // 1.6% overhead reserved


const rx_has_space = (/\s/)
const has_space = rx_has_space.test.bind(rx_has_space)

export function as_hdr({id_route, id_target, op}) ::
  // Check for use errors with id_target or id_route.
  if 'string' !== typeof id_route :: throw new TypeError @ 'Invalid id_route'
  else if has_space(id_route) :: throw new TypeError @ 'Invalid id_route with spaces'
  if 'string' !== typeof id_target :: throw new TypeError @ 'Invalid id_target'
  else if has_space(id_target) :: throw new TypeError @ 'Invalid id_target with spaces'

  // We could check that the op list entries have no spaces;
  // however that would be a bug with the library generating them.
  return op && op.length
    ? `${id_route} ${id_target} ${op?op.join(' '):''}`
    : `${id_route} ${id_target}`

export const o_create = Object.create
export function as_pkt0(hdr, meta, body, aPktBase) ::
  if maxlen_hdr < hdr.length ::
    throw new Error @ 'Packet header too large'

  const len = (null == meta ? 0 : meta.length + 4) + body.length
  if maxlen_msg < len ::
    throw new Error @ 'Packet body too large'

  return o_create @ aPktBase, @{}
    _hdr_: @{} value: hdr.split(' ')
    _meta_: @{} value: meta
    _body_: @{} value: body


export function is_json_body(body) ::
  if null == body :: return true
  return undefined === body.byteLength
    && 'string' !== typeof body

export function bind_repack(repackByKind) ::
  return (pkt, pkt_kind) =>
    repackByKind[pkt_kind] @
      pkt, pkt._hdr_.join(' ')

