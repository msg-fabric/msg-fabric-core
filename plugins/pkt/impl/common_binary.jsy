import { is_json_body, json_stringify, json_parse, bind_repack } from './common_base.jsy'
import { as_hdr, as_pkt0 } from './common_base.jsy'

import { k_data, k_split_data, k_json, k_split_json, sym_split } from './common.jsy'
import { PktSplitJson, PktSplitData } from './common.jsy'
import { bind_packObjPacket } from './common.jsy'

export { PktJsonBase, PktDataBase } from './common.jsy'

export function bind_binaryCallPacket(options) ::
  const _common_ = bind_binaryPacketCommon(options)
  const _unpackBySlice = _common_._unpackBinaryPacketBySlice
  _common_.unpackBinaryPacket = unpackBinaryCallPacket
  return _common_

  function unpackBinaryCallPacket(pkt_buf) ::
    return _unpackBySlice @ pkt_buf, 0


export function bind_binaryLenPacket(options) ::
  const _common_ = bind_binaryPacketCommon(options)
  const _unpackBySlice = _common_._unpackBinaryPacketBySlice
  _common_.unpackBinaryPacket = unpackBinaryLenPacket
  return _common_

  function unpackBinaryLenPacket(pkt_buf) ::
    const len = pkt_buf[0] | pkt_buf[1]<<8 // as Uint16 LE
    if len !== pkt_buf.length ::
      throw new Error @ 'Invalid packet length'

    return _unpackBySlice @ pkt_buf, 2


const _fromCharCode = String.fromCharCode
export function bind_binaryPacketCommon(options) ::
  const @{}
    decode_utf8, unpack_base64, packParts
    PktData, PktJson
  = options

  const pktByKind = @{}
    [k_data]: PktData, [k_split_data]: PktSplitData
    [k_json]: PktJson, [k_split_json]: PktSplitJson

  const repack_binary = bind_repack @:
    json: (pkt, hdr) => packParts @ `${hdr}\t${k_json}${pkt._meta_}\t${pkt.text()}`
    split_json: (pkt, hdr) => packParts @ `${hdr}\t${k_split_json}${pkt._meta_}\t${pkt._body_}`

    data: (pkt, hdr) => packParts @ `${hdr}\t${k_data}${pkt._meta_}\t`, pkt.buffer()
    split_data: (pkt, hdr) => packParts @ `${hdr}\t${k_split_data}${pkt._meta_}\t`, pkt._body_
    split_b64: (pkt, hdr) => packParts @ `${hdr}\t${k_split_data}${pkt._meta_}\t`, unpack_base64(pkt._body_)

  return @{}
    packBinaryPacket(obj) ::
      if 'function' === typeof obj.repack_pkt ::
        return obj.repack_pkt(repack_binary)

      const hdr=as_hdr(obj), {body, meta}=obj, k_token=body[sym_split]
      return undefined !== k_token
        ? @ undefined !== body.src
            ? packParts @ `${hdr}\t${k_token}${obj._meta_}\t${body.src}`
            : packParts @ `${hdr}\t${k_token}${obj._meta_}\t`, body.buf

        : @ is_json_body(body)
            ? packParts @ `${hdr}\t${k_json}${json_stringify(meta)||''}\t${json_stringify(body)||''}`
            : packParts @ `${hdr}\t${k_data}${json_stringify(meta)||''}\t`, body

    _unpackBinaryPacketBySlice(pkt_buf, i0) ::
      // 0x9 == '\t'.charCodeAt(0)
      const i1 = pkt_buf.indexOf(0x9, i0)
      const i2 = pkt_buf.indexOf(0x9, 1+i1)
      if -1 === i1 || -1 === i2 ::
        throw new Error @ 'Invalid packet'

      const hdr = decode_utf8 @ pkt_buf.slice(i0, i1)
      const kind = _fromCharCode @ pkt_buf[1+i1]
      const meta = decode_utf8 @ pkt_buf.slice(2+i1, i2)
      const body = pkt_buf.slice(1+i2)

      return as_pkt0 @ hdr, meta, body, pktByKind[kind]

    fromObjBinaryPacket: bind_packObjPacket(options, repack_binary)

