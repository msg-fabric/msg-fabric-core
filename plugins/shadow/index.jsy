const default_options = @{}
  name: 'shadow'
  order: 5
  shadow_id(id_target) ::
    // return id_shadow for selected entries; otherwise return null to skip
    return null
  encode(pkt, ua8, id_shadow, id_target) ::
    return ua8
  decode(enc_pkt, ua8, id_shadow, id_target) ::
    return ua8
  

export default function shadow_pkt_plugin(plugin_options) ::
  throw new Error @ 'TODO: update shadow_pkt_plugin to latest API'

  plugin_options = Object.assign @ {}, default_options, plugin_options
  const {shadow_id, encode, decode} = plugin_options

  return @: order: plugin_options.order
    subclass(FabricHub) ::
      const proto_hub = FabricHub.prototype
      const base_fromObjPacket = proto_hub._fromObjPacket
      const { encode_utf8 } = proto_hub.data_utils
      const { fromObjBinaryPacket, packBinaryPacket, unpackBinaryPacket } = proto_hub._pkts_.bin_call

      const plugin = Object.assign @ shadowTarget, @{}
        target: shadowTarget
        async fromObjPacket(obj) ::
          const pkt = await base_fromObjPacket(obj)
          const id_target = pkt.id_target
          const id_shadow = shadow_id(id_target, pkt)
          return id_shadow ? await shadow_encode(pkt, id_shadow, id_target) : pkt


      Object.assign @ FabricHub.prototype, @{}
        _fromObjPacket: plugin.fromObjPacket
        [plugin_options.name]: plugin
      return plugin


      function shadowTarget(id_target, target) ::
        const id_shadow = shadow_id(id_target)
        if ! id_shadow ::
          throw new Error @ 'Invalid id_shadow for id_target'

        let shadow_target
        if 'function' === typeof target ::
          shadow_target = async function (enc_pkt, pktctx) ::
            const pkt = await shadow_decode(enc_pkt, id_shadow, id_target)
            return await target @ pkt, pktctx

        else if true === target ::
          shadow_target = async function (enc_pkt, pktctx) ::
            const pkt = await shadow_decode(enc_pkt, id_shadow, id_target)
            return await pktctx.redispatch @ pkt, pktctx

        else throw new TypeError @ `Expected 'target' function`

        shadow_target.id_target = id_shadow
        return shadow_target


      function shadow_encode(pkt, id_shadow, id_target) ::
        const sobj = @{} id_route: pkt.id_route, id_target: id_shadow, on_sent: pkt.on_sent

        pkt._hdr_[0] = pkt._hdr_[1] = ''
        let dec_raw = packBinaryPacket(pkt)
        if 'string' === typeof dec_raw ::
          // string is a valid (and common) subset of binary packets; normalize
          dec_raw = encode_utf8(dec_raw)

        const enc_raw = encode @ pkt, dec_raw, id_shadow, id_target
        Object.assign @ sobj, enc_raw.length ? {body: enc_raw} : enc_raw
        return fromObjBinaryPacket @ sobj


      function shadow_decode(enc_pkt, id_shadow, id_target) ::
        const dec_raw = decode @ enc_pkt, enc_pkt.buffer(), id_shadow, id_target
        const pkt = unpackBinaryPacket @ dec_raw
        pkt._hdr_[0] = enc_pkt._hdr_[0]
        pkt._hdr_[1] = id_target
        return pkt

