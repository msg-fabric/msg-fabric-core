export default stream_common
export function stream_common(hub) ::
  const createRWChannel = bind_channel(hub)
  return @{} createRWChannel


export function bind_channel(hub) ::
  const createChannel = hub._pkts_.bin_call.createChannel

  return function (rstream, wstream, channel_id) ::
    const pkt_hdr = Buffer.alloc(2)
    send_packed.channel_id = channel_id
    const [recv, channel] = createChannel @ hub.router.dispatch, send_packed
    recvPacketStream @ rstream, recv

    let p_drain=null, on_drain
    wstream.on @ 'drain', @=> ::
      p_drain = null
      if null !== on_drain ::
        on_drain()
        on_drain = null

    function next_drain() ::
      if null === p_drain ::
        p_drain = new Promise @
          resolve => :: on_drain = resolve
      return p_drain

    channel.when_closed = new Promise @ resolve => ::
      rstream.once @ 'end', resolve
      wstream.once @ 'finish', resolve

    return channel

    function send_packed(d_pkt) ::
      if null === d_pkt ::
        wstream.end()
        return new Promise @ resolve =>
          wstream.once @ 'finish', resolve

      d_pkt = Buffer.from(d_pkt)
      pkt_hdr.writeUInt16LE(2 + d_pkt.byteLength, 0)
      const s_pkt = Buffer.concat @# pkt_hdr, d_pkt
      if wstream.write(s_pkt) ::
        return // sent immediate, no backpressure promise
      // backpressure as promise for next drain event
      return next_drain()



export function recvPacketStream(rstream, dispatchCallback) ::
  return new Promise @ (resolve, reject) => ::
    rstream.on @ 'error', shutdown
    rstream.on @ 'close', shutdown
    rstream.on @ 'data'
      binaryLenPrefixFeedUint16LE @ shutdown, dispatchCallback

    function shutdown(err) ::
      if undefined !== rstream ::
        rstream.end()
        rstream = undefined
        err ? reject(err) : resolve()



export function binaryLenPrefixFeedUint16LE(shutdown, dispatchCallback) ::
  let tipLen=null, byteLen=0, q=[]

  return function(data) ::
    q.push(data) ; byteLen += data.byteLength

    const pktList = []
    while 1 ::
      const buf = parseNext()
      if undefined !== buf ::
        pktList.push @ buf
      else break

    if 0 !== pktList.length ::
      try ::
        return dispatchCallback(pktList)
      catch err ::
        return shutdown(err)

  function parseNext() ::
    if null === tipLen ::
      if byteLen < 2 :: return

      const buf = Buffer.concat(q)
      tipLen = buf.readUInt16LE(0)
      q = [buf]

      if tipLen < 4 ::
        shutdown @ new Error @ 'Binary stream framing error'
        return

    if tipLen <= byteLen ::
      const buf_q = 1===q.length ? q[0]
        : Buffer.concat(q)

      const buf = buf_q.slice(0, tipLen)
      q = [buf_q.slice(tipLen)]
      byteLen -= tipLen
      tipLen = null
      return buf.slice(2)

