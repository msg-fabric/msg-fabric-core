export default stream_common
export function stream_common(hub) ::
  const createRWChannel = bind_channel(hub)
  return @{} createRWChannel


export function bind_channel(hub) ::
  const createChannel = hub._pkts_node_.bin_len.createChannel

  return function (rstream, wstream) ::
    const [recv, channel] = createChannel @ hub.dispatch, send_packed
    recvPacketStream @ rstream, recv

    let p_drain=null, on_drain
    wstream.on @ 'drain', @=> ::
      p_drain = null
      if null !== on_drain ::
        on_drain()
        on_drain = null

    function next_drain(resolve) ::
      if undefined === resolve ::
        on_drain = resolve
      else if null === p_drain ::
        p_drain = new Promise(next_drain)
      return p_drain

    return channel

    function send_packed(d_pkt) ::
      if null !== d_pkt ::
        if wstream.write(d_pkt) ::
          return // sent immediate, no backpressure promise
        // backpressure as promise for next drain event
        return set_drain()
      else ::
        wstream.end()
        return new Promise @ resolve =>
          wstream.once @ 'finish', resolve



export function recvPacketStream(rstream, dispatchCallback) ::
  return new Promise @ (resolve, reject) => ::
    rstream.on @ 'error', shutdown
    rstream.on @ 'close', shutdown
    rstream.on @ 'data'
      binaryLenPrefixFeedUint16LE @ shutdown, dispatchCallback

    function shutdown(err) ::
      if undefined !== rstream ::
        rstream.end()
        rstream = undefined
        err ? reject(err) : resolve()



export function binaryLenPrefixFeedUint16LE(shutdown, dispatchCallback) ::
  let tipLen=null, byteLen=0, q=[]

  return function(data) ::
    q.push(data) ; byteLen += data.byteLength

    const pktList = []
    while 1 ::
      const buf = parseNext()
      if undefined !== buf ::
        pktList.push @ buf
      else break

    if 0 !== pktList.length ::
      try ::
        return dispatchCallback(pktList)
      catch err ::
        return shutdown(err)

  function parseNext() ::
    if null === tipLen ::
      if byteLen < 2 :: return

      const buf = Buffer.concat(q)
      tipLen = buf.readUInt16LE(0)
      q = [buf]

      if tipLen < 4 ::
        shutdown @ new Error @ 'Binary stream framing error'
        return

    if tipLen <= byteLen ::
      const buf_q = 1===q.length ? q[0]
        : Buffer.concat(q)

      const buf = buf_q.slice(0, tipLen)
      q = [buf_q.slice(tipLen)]
      byteLen -= tipLen
      tipLen = null
      return buf

