export const channel_base = {}

export default stream_common
export function stream_common(hub) ::
  const createRWChannel = bind_channelDispatch(hub, channel_base)
  return @{} channel_base, createRWChannel


export function bind_channelDispatch(hub, channel_base) ::
  const createChannel = hub._pkts_node_.bin_len.createChannel

  return function (rstream, wstream, chan_base=channel_base) ::
    const [recv, channel] = createChannel @ hub.dispatch, send_packed, chan_base
    recvPacketStream @ rstream, recv
    return channel

    function send_packed(d_pkt) ::
      if null !== d_pkt ::
        wstream.write(d_pkt)
      else wstream.end()


export function recvPacketStream(rstream, dispatchCallback) ::
  return new Promise @ (resolve, reject) => ::
    rstream.on @ 'error', shutdown
    rstream.on @ 'close', shutdown
    rstream.on @ 'data'
      binaryLenPrefixFeedUint16LE @ shutdown, dispatchCallback

    function shutdown(err) ::
      if undefined !== rstream ::
        rstream.end()
        rstream = undefined
        err ? reject(err) : resolve()



export function binaryLenPrefixFeedUint16LE(shutdown, dispatchCallback) ::
  let tipLen=null, byteLen=0, q=[]

  return function(data) ::
    q.push(data) ; byteLen += data.byteLength

    const pktList = []
    while 1 ::
      const buf = parseNext()
      if undefined !== buf ::
        pktList.push @ buf
      else if 0 !== pktList.length ::
        try ::
          return dispatchCallback(pktList)
        catch err ::
          return shutdown(err)

  function parseNext() ::
    if null === tipLen ::
      if byteLen < 2 :: return

      const buf = Buffer.concat(q)
      tipLen = buf.readUInt16LE(0)
      q = [buf]

      if tipLen < 4 ::
        shutdown @ new Error @ 'Binary stream framing error'
        return

    if tipLen <= byteLen ::
      const buf_q = 1===q.length ? q[0]
        : Buffer.concat(q)

      const buf = buf_q.slice(0, tipLen)
      q = [buf_q.slice(tipLen)]
      byteLen -= tipLen
      tipLen = null
      return buf

