
export function bind_rpc_client(tgt_router) ::
  const rpc_api_proxy = @{}
    get(obj, prop, pxy) ::
      if 'string' === typeof prop ::
        if prop.includes('$') ::
          let method_obj = Object.assign @ () => prop, obj
          return new Proxy @ method_obj, rpc_method_proxy

        let rpc_fn = this['rpc_'+prop]
        if 'function' === typeof rpc_fn ::
          return rpc_fn.bind(pxy, obj)

      return obj

    rpc_timeout(obj, ms) ::
      obj.ms_timeout = ms
      return this


  const rpc_method_proxy = @{}
    __proto__: rpc_api_proxy

    apply(method_obj, a_this, args) ::
      return this.rpc_query @ method_obj, ...args

    async rpc_query(method_obj, ...args) ::
      let { id, meta, ms_timeout } = method_obj
      let r = tgt_router.addReply(ms_timeout)
      let p = r.response()
      await tgt_router.send @: 0: id[0], 1: id[1], meta,
        body: @[] '!', r.id, method_obj(), ...args
      return await p

    async rpc_post(method_obj, ...args) ::
      let { id, meta } = method_obj
      await tgt_router.send @: 0: id[0], 1: id[1], meta,
        body: @[] '!', null, method_obj(), ...args


  return (id, meta) => ::
    if ! Array.isArray(id) || ! id[0] ::
      throw new TypeError

    return new Proxy @ {id, meta}, rpc_api_proxy

