export const rx_rpc = /[\$\s]/

export class RPC ::
  static create(rpc_api) ::
    return new this(rpc_api)

  constructor(rpc_api) ::
    this.rpc_api = rpc_api

  with(rpc_api) ::
    return @{} __proto__: this, rpc_api

  get rpc_stream() ::
    // return a bound method, like python
    return async xtgt => ::
      for await let [pkt, pktctx] of xtgt.stream || xtgt ::
        await this.rpc(pkt.body, pktctx)

  get rpc_pkt() ::
    // return a bound method, like python
    return (pkt, pktctx) =>
      this.rpc(pkt.body, pktctx)

  async rpc(rpc_call, pktctx) ::
    let fn = this.bind_rpc(rpc_call, pktctx)
    if fn ::
      let r = await fn()
      if r !== pktctx ::
        let reply = pktctx.reply
        if reply ::
          await reply(r)

  bind_rpc(rpc_call, pktctx) ::
    if Array.isArray(rpc_call) ::
      // rpc_call: @[] '!', id_reply, method, ... args
      let [is_rpc,, method] = rpc_call
      if '!' === is_rpc || 'string' === typeof method ::
        let rpc_fn = this.lookup_name(method)
        return rpc_fn
          ? this._bind_rpc(rpc_fn, rpc_call, pktctx)
          : this._bind_dnu(method, pktctx)
    // otherwise, invalid rpc_call

  lookup_name(method) ::
    return rx_rpc.test(method) && this.rpc_api[method]

  _bind_rpc(rpc_fn, rpc_call, pktctx) ::
    // rpc_call: @[] '!', id_reply, method, ... args
    let [, id_reply,, ... args] = rpc_call
    if id_reply :: // id_reply
      this._bind_reply(id_reply, pktctx)
    return rpc_fn.bind(this.rpc_api, pktctx, ... args)

  _bind_reply(id_reply, pktctx) ::
    return Object.assign @ pktctx, @{}
      reply: pktctx.to(id_reply)
      done() ::
        this.reply = null
        return this


  _bind_dnu(method, pktctx) ::
    let {rpc_api}=this, fn = rpc_api.__dnu__
    return fn ? fn.bind(rpc_api, method, pktctx)
      : this.rpc_dnu.bind(this, rpc_api, method, pktctx)

  rpc_dnu(rpc_api, method, pktctx) ::
    // DNU is "does not understand" convention from Smalltalk.
    console.warn @ `RPC DNU`, @{} method, rpc_api

