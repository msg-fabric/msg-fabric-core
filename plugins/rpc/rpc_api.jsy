

export function bind_rpc_api_dispatch(send, base_rpc_options) ::
  const _f_ident = v => v
  const _with_pkt = (params, {pkt}) => ( params.unshift(pkt), params )

  const _as_api_fn = (api, name, args) =>
    api[name] && @=> api[name](...args)

  const _as_rpc_reply = (rpc_fn, id_reply) =>
    @::>
      // TODO: What about exceptions?
      let body = await rpc_fn()
      await send({0: id_reply[0], 1: id_reply[1], body})

  base_rpc_options = @{}
    prefix: 'm$', dnu: '__dnu__'
    extend_api: _f_ident
    params: false
    parallel: false

    ... base_rpc_options

  return api_binder

  function api_binder(api) ::
    let rpc_options = @{} __proto__: base_rpc_options, ... api.rpc_options
    let { prefix, dnu, extend_api, params, parallel } = rpc_options
    params = _as_bind_params(params)

    return @{} rpc_binder,
      as_dispatch: (parallel ? _disp_parallel : _disp_serial)(rpc_binder)

    function rpc_binder(call, pkt) ::
      // call: @[] '!', id_reply, method, ... args
      let [is_rpc, id_reply, method, ... args] = call

      if '!' !== is_rpc || 'string' !== typeof method ::
        return null // invalid rpc call

      let valid = method.startsWith(prefix)
      let call_ctx = @{} pkt, args, call, method, valid, send
      let _api = extend_api(api, call_ctx)
      
      let rpc_fn = @ valid
        && _as_api_fn(_api, method, params(args, call_ctx))
        || _as_api_fn(_api, dnu, [method, call_ctx])

      // TODO: What about exceptions?
      return id_reply
        ? _as_rpc_reply(rpc_fn, id_reply)
        : rpc_fn


  function _as_bind_params(key) ::
    switch typeof key ::
      case 'function':
        return key

      case 'boolean':
        return key ? _with_pkt : _f_ident

      case 'string':
        return (params, ns) => @
          params.unshift(ns[key])
          params

      default: throw TypeError

  function _disp_parallel(rpc_binder) ::
    return @\ pkt ::
      let api_fn = rpc_binder(pkt.body, pkt)
      if api_fn ::
        return api_fn()

  function _disp_serial(rpc_binder) ::
    let p = Promise.resolve()
    return @\ pkt ::
      let api_fn = rpc_binder(pkt.body, pkt)
      if api_fn ::
        return p = p.then(api_fn, api_fn)

