const _fromCharCode = String.fromCharCode
const _charCodeAt = ''.charCodeAt

export default function browser_platform_plugin(plugin_options={}) ::
  return @: order: -9, subclass(FabricHub) ::

    for const base of [FabricHub, FabricHub.TargetRouter, FabricHub.P2PRouter] ::
      Object.assign @ base.prototype, @{} data_utils

const data_utils = @{}
  parse_url
  random, random_base64,
  pack_base64, unpack_base64
  decode_utf8, encode_utf8
  as_data, concat_data

function random(n) ::
  const ua = new Uint8Array(n)
  window.crypto.getRandomValues(ua)
  return ua

function random_base64(n) ::
  const ua = new Uint8Array(n)
  window.crypto.getRandomValues(ua)
  return pack_base64 @ ua

function parse_url(url) ::
  return new URL(url)

function pack_base64(data) ::
  const u8 = new Uint8Array(data.buffer || data), len = u8.byteLength

  let res=''
  for (let i=0; i<len; i++)
    res += _fromCharCode(u8[i])
  return window.btoa(res)

function unpack_base64(str_b64) ::
  const sz = window.atob(str_b64), len = sz.length

  const res = new Uint8Array(len)
  for (let i=0; i<len; i++)
    res[i] += _charCodeAt.call(sz, i)
  return res

function decode_utf8(u8) ::
  if undefined === u8.byteLength ::
    throw new Error @ 'Expected TypedArray'
  const buf = u8.buffer || new ArrayBuffer(u8)
  return new TextDecoder().decode(buf)

function encode_utf8(str) ::
  return new TextEncoder().encode(str)

function as_data(data) ::
  if null === data ::
    return new ArrayBuffer(0)
  return 'string' === typeof data
    ? encode_utf8(data)
    : new ArrayBuffer(data)

function concat_data(parts) ::
  let i=0, len=0
  for const b of parts ::
    len += b.byteLength

  const ua = new Uint8Array(len)
  for const b of parts ::
    ua.set @ new Uint8Array(b.buffer || b), i
    i += b.byteLength
  return ua

