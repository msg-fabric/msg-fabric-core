import { o_create, o_assign } from './util.jsy'
import { deferred, timeoutReaper } from './util.jsy'

export const sym_sampi = '\u03E0' // 'Ϡ'

export function as_source_id(id) ::
  return 'string' === typeof id ? id.split(' ', 2)
    : 'string' === typeof id[sym_sampi] ? id[sym_sampi].split(' ', 2)
    : @[] id.id_route, id.id_target

export function as_reply_id(id) ::
  return 'string' === typeof id ? id.split(' ', 2)
    : 'string' === typeof id[sym_sampi] ? id[sym_sampi].split(' ', 2)
    : @[] id.from_route, id.from_target

export function make_reply_id({id_route, from_route, id_target, from_target, token}, token2) ::
  if null == token :: token = token2
  if null == from_route :: from_route = id_route
  if null == from_target :: from_target = id_target
  return @{} token: token, from: true, from_route, from_target


export function bind_mx_api(source_api, reply_api) ::
  return (pkt_op, _mx_) => ::
    const props = @{}
      _mx_: {value: _mx_}
      [sym_sampi]: @{} enumerable: true,
        value: `${_mx_.id_route} ${_mx_.id_target}`

    if null != pkt_op && pkt_op.token ::
      _mx_.opo0.msgid = pkt_op.token
      return o_create @ reply_api, props
    return o_create @ source_api, props


export default msg_base_api
export function msg_base_api(hub, options) ::
  const {splitBody, joinPackets} = hub._pkts_
  const random_base64 = hub.data_utils.random_base64

  const chan = options.channel || hub.channel
  const tokenLen = Math.max @ 1, options.tokenLen || 3 | 0
  const expire = timeoutReaper @ options.timeout || 5000
  const newToken = options.newToken || @ () => random_base64(tokenLen)

  const msg_api0 = bind_msg_api0(chan, options.msg_stream)

  return @{}
    newToken, expire, msg_api0
    bind_msg_api
    bind_sendmsg
    bind_replymsg

    createMsgContext() ::
      let db = new Map()
      return @{} newToken
        deferredFor(token) ::
          if ! token :: return
          let d = db.get(token)
          if undefined !== d :: return d
          d = deferred()
          db.set(token, d)

          expire(d.reject)
          const remove = @=> db.delete(token)
          d.promise.then @ remove, remove
          return d

        responseFor(token) ::
          return this.deferredFor(token).promise

        on_resolve(msgid, ans) ::
          if ! msgid :: return ans
          const d = db.get(msgid)
          if undefined === d :: return ans
          expire @=> db.delete(msgid)
          d.resolve(ans)
          return null

        on_split_pkt(pkt, op) ::
          const key = '~ ' + (op.token || op.msgid)
          let d = db.get(key)
          if undefined === d ::
            d = this.deferredFor(key)
            d.feed = this.on_new_split(key, d)
          else if undefined === d.feed ::
            d.feed = this.on_new_split(key, d)

          pkt.complete = d.promise
          return d.feed(pkt, op)

        on_new_split(key, d) ::
          let fin, parts=[]
          return function (pkt, op) ::
            const {seq} = op
            if seq >= 0 ::
              parts[seq] = pkt
              if ! fin :: return null
            else ::
              parts[-seq] = pkt
              fin = true

            if ! parts.includes(undefined) ::
              // all parts accounted for
              const multi = joinPackets(parts)
              parts = null
              d.resolve(multi)
              expire @=> db.delete(key)
              return multi
            return null


  function bind_sendmsg(kw) ::
    const api = bind_msg_api(kw)
    api.send = api.post
    api.dg_send = api.dg_post
    return api

  function bind_replymsg(kw) ::
    const api = bind_msg_api(kw)
    api.send = api.answer
    api.dg_send = api.dg_answer
    api.replyExpected = true
    return api

  function bind_msg_api({anon, op_api}) ::
    return @{} __proto__: msg_api0, anon
      post: _mp_post
      query: _mp_with_response
      answer: _mp_with_response

      dg_post: _dg_post
      dg_query: _dg_response
      dg_answer: _dg_response

      stream(extra) ::
        const {meta} = extra || {}
        const {response, opo} = this._new_response()
        const ms = this._msg_stream(this, opo, op_api.stream, meta)
        ms.response = response
        return ms

      multipart(extra) ::
        const {meta} = extra || {}
        const {response, opo} = this._new_response()
        const ms = this._msg_stream(this, opo, op_api.multipart, meta)
        ms.response = response
        return ms

      ctrl(body, extra) ::
        const meta = undefined !== extra && null !== extra
          ? extra.meta : undefined

        const {response, opo} = this._new_response()
        const {id_route, id_target} = this._mx_
        const obj = @{} id_route, id_target, body, meta
        const pkt = op_api.ctrl @ obj, opo
        this._send_pkt(pkt)
        return response


    function _mp_post(body, extra) ::
      const meta = undefined !== extra && null !== extra
        ? extra.meta : undefined

      const parts = splitBody(body, meta)
      if 1 < parts.length ::
        const {opo} = this._new_token()
        this._msg_stream(this, opo, op_api.split_datagram)
          .writeAll(parts, true)
        return

      const {id_route, id_target, opo0} = this._mx_
      const obj = @{} id_route, id_target, body: parts[0], meta
      const pkt = op_api.datagram @ obj, opo0
      this._send_pkt(pkt)

    function _mp_with_response(body, extra) ::
      const meta = undefined !== extra && null !== extra
        ? extra.meta : undefined
      const {response, opo} = this._new_response()

      const parts = splitBody(body, meta)
      if 1 < parts.length ::
        this._msg_stream(this, opo, op_api.split_direct)
          .writeAll(parts, true)
        return response

      const {id_route, id_target} = this._mx_
      const obj = @{} id_route, id_target, body: parts[0], meta
      const pkt = op_api.direct @ obj, opo
      this._send_pkt(pkt)
      return response

    function _dg_post(body, extra) ::
      const meta = undefined !== extra && null !== extra
        ? extra.meta : undefined
      const {id_route, id_target, opo0} = this._mx_
      const obj = @{} id_route, id_target, body, meta
      const pkt = op_api.datagram @ obj, opo0
      this._send_pkt(pkt)

    function _dg_response(body, extra) ::
      const meta = undefined !== extra && null !== extra
        ? extra.meta : undefined
      const {response, opo} = this._new_response()
      const {id_route, id_target} = this._mx_
      const obj = @{} id_route, id_target, body, meta
      const pkt = op_api.direct @ obj, opo
      this._send_pkt(pkt)
      return response

  function bind_msg_api0(chan, msg_stream) ::
    return @{} __proto__: null
      inspect() :: return `«${sym_sampi} ${this[sym_sampi]}»`
      toJSON() :: return @{} [sym_sampi]: this[sym_sampi]

      _msg_stream: msg_stream
      _send_pkt: chan.send.bind(chan)

      _new_token() ::
        const {mctx, opo0} = this._mx_
        const token = mctx.newToken()
        return @{} token,
          opo: o_assign @ {token}, opo0

      _new_response() ::
        const {mctx, opo0} = this._mx_
        if opo0.msgid :: return @{} opo: opo0

        const token = mctx.newToken()
        return @{} token,
          opo: o_assign @ {token}, opo0
          response: mctx.responseFor(token)

