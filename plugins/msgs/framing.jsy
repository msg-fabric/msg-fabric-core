const _b16_unpack = v => parseInt(v, 16)|0
const _b16_pack = v => (v|0).toString(16)
const _is_defined = (attr, v) => ::
  if undefined === v :: throw new Error(attr)
  return v

const frm = @{}
  _b16_pack, _b16_unpack, _is_defined

  msgid: @{} attr: 'msgid'
    unpack: (v, hdr) => :: hdr.msgid = v
    pack: hdr => _is_defined @ 'msgid', hdr.msgid

  token: @{} attr: 'token'
    unpack: (v, hdr) => :: hdr.token = v
    pack: hdr => _is_defined @ 'token', hdr.token

  from_route: @{} attr: 'from_route'
    unpack: (v, hdr) => :: hdr.from=true; hdr.from_route = v
    pack: hdr => _is_defined @ 'from_route', hdr.from_route

  from_target: @{} attr: 'from_target'
    unpack: (v, hdr) => :: hdr.from_target = v
    pack: hdr => _is_defined @ 'from_target', hdr.from_target

  seq: @{} attr: 'seq'
    unpack: (v, hdr) => :: hdr.seq = _b16_unpack @ v
    pack: hdr => _b16_pack @ _is_defined @ 'seq', hdr.seq



function as_op_frame(op_frame) ::
  let {kind, action, frames, pack, unpack} = op_frame

  if null == frames :: frames = []
  frames.unshift @: attr: 'action'
    unpack: (v, hdr) => :: hdr.kind = kind
    pack: hdr => action

  if null == pack ::
    const f_pack = frames
      .map @ f => f.pack ? f.pack.bind(f) : null
      .filter @ e => null !== e
    const bind = _as_pack_fn[f_pack.length] || _as_packN_fn
    pack = bind(...f_pack)

  if null == unpack ::
    const f_unpack = frames
      .map @ f => f.unpack ? f.unpack.bind(f) : null
      .filter @ e => null !== e

    const bind = _as_unpack_fn[f_unpack.length] || _as_unpackN_fn
    unpack = bind(...f_unpack)

  return Object.assign @ op_frame, @{}
    attrs: frames.map @ f => f.attr
    frames, pack, unpack


// unroll looping over the functions
const _as_pack_fn = @[]
  () => hdr => @#
  (f0) => hdr => @# f0(hdr)
  (f0, f1) => hdr => @# f0(hdr), f1(hdr)
  (f0, f1, f2) => hdr => @# f0(hdr), f1(hdr), f2(hdr)
  (f0, f1, f2, f3) => hdr => @# f0(hdr), f1(hdr), f2(hdr), f3(hdr)
  (f0, f1, f2, f3, f4) => hdr => @# f0(hdr), f1(hdr), f2(hdr), f3(hdr), f4(hdr)

const _as_packN_fn = (...fns) =>
  hdr => fns.map @ f => f(hdr)

// unroll looping over the functions
const _as_unpack_fn = @[]
  () => (hdr, op) => @ op
  (f0) => (hdr, op) => @ f0(hdr[2], op), op
  (f0, f1) => (hdr, op) => @ f0(hdr[2], op), f1(hdr[3], op), op
  (f0, f1, f2) => (hdr, op) => @ f0(hdr[2], op), f1(hdr[3], op), f2(hdr[4], op), op
  (f0, f1, f2, f3) => (hdr, op) => @ f0(hdr[2], op), f1(hdr[3], op), f2(hdr[4], op), f3(hdr[5], op), op
  (f0, f1, f2, f3, f4) => (hdr, op) => @ f0(hdr[2], op), f1(hdr[3], op), f2(hdr[4], op), f3(hdr[5], op), f4(hdr[6], op), op

const _as_unpackN_fn = (...fns) =>
  (hdr, op) => ::
    let i=2
    for const f of fns :: f(hdr[i++], op)
    return op


export function standard_frames(_as_op_frame) ::
  if null == _as_op_frame :: _as_op_frame = as_op_frame

  return @[]
    // control datagram:
    _as_op_frame @: kind: 'ctrl', action: '?', frames: @# frm.token
    _as_op_frame @: kind: 'ctrl', action: '!', frames: @# frm.msgid

    // datagram:
    _as_op_frame @: kind: 'datagram', action: '-', frames: @#
    _as_op_frame @: kind: 'datagram', action: '@', frames: @# frm.from_route, frm.from_target

    // split_datagram: a multipart style encoding for when a message has to be split over multiple packets
    _as_op_frame @: kind: 'split_datagram', action: 'A', frames: @# frm.token, frm.seq
    _as_op_frame @: kind: 'split_datagram', action: 'a', frames: @# frm.msgid, frm.seq
    _as_op_frame @: kind: 'split_datagram', action: 'B', frames: @# frm.from_route, frm.from_target, frm.token, frm.seq
    _as_op_frame @: kind: 'split_datagram', action: 'b', frames: @# frm.from_route, frm.from_target, frm.msgid, frm.seq

    // direct: 
    _as_op_frame @: kind: 'direct', action: 'E', frames: @# frm.token
    _as_op_frame @: kind: 'direct', action: 'e', frames: @# frm.msgid
    _as_op_frame @: kind: 'direct', action: 'D', frames: @# frm.from_route, frm.from_target, frm.token
    _as_op_frame @: kind: 'direct', action: 'd', frames: @# frm.from_route, frm.from_target, frm.msgid

    // split_direct: a multipart style encoding for when a message has to be split over multiple packets
    _as_op_frame @: kind: 'split_direct', action: 'F', frames: @# frm.token, frm.seq
    _as_op_frame @: kind: 'split_direct', action: 'f', frames: @# frm.msgid, frm.seq
    _as_op_frame @: kind: 'split_direct', action: 'G', frames: @# frm.from_route, frm.from_target, frm.token, frm.seq
    _as_op_frame @: kind: 'split_direct', action: 'g', frames: @# frm.from_route, frm.from_target, frm.msgid, frm.seq

    // multipart:
    _as_op_frame @: kind: 'multipart', action: 'U', frames: @# frm.token, frm.seq
    _as_op_frame @: kind: 'multipart', action: 'u', frames: @# frm.msgid, frm.seq
    _as_op_frame @: kind: 'multipart', action: 'M', frames: @# frm.from_route, frm.from_target, frm.token, frm.seq
    _as_op_frame @: kind: 'multipart', action: 'm', frames: @# frm.from_route, frm.from_target, frm.msgid, frm.seq

    // streaming:
    _as_op_frame @: kind: 'stream', action: 'R', frames: @# frm.token, frm.seq
    _as_op_frame @: kind: 'stream', action: 'r', frames: @# frm.msgid, frm.seq
    _as_op_frame @: kind: 'stream', action: 'S', frames: @# frm.from_route, frm.from_target, frm.token, frm.seq
    _as_op_frame @: kind: 'stream', action: 's', frames: @# frm.from_route, frm.from_target, frm.msgid, frm.seq



function ident(op) :: return op
export function bind_op_unpack(ops_list) ::
  const op_unpack_table = @{} '': ident, ' ': ident
  for const op of ops_list ::
    op_unpack_table[op.action] = op.unpack
  return op_unpack

  function op_unpack(pkt, op) ::
    const hdr = pkt._hdr_
    const unpack = op_unpack_table[hdr[2]] || ident
    unpack(hdr, op)
    return pkt.op = hdr.op = op


function as_ops_api(ops_list) ::
  const api = {}
  for const {kind, pack} of ops_list ::
    api[kind] = function(obj, hdr) ::
      obj.op = pack(hdr)
      return obj
  return api



export default msg_framing_api
export function msg_framing_api(shared, ext_framings) ::
  if 'function' === typeof ext_framings ::
    ext_framings = @{} frames: ext_framings

  let all_ops, op_unpack, _as_ops_api=as_ops_api

  if ext_framings ::
    all_ops = ext_framings.frames @: frm, as_op_frame, standard_frames
    if ext_framings.bind_op_unpack ::
      op_unpack = ext_framings.bind_op_unpack(all_ops, bind_op_unpack)
    if ext_framings.bind_ops_api ::
      _as_ops_api = ext_framings.bind_ops_api(as_ops_api)

  if undefined === all_ops ::
    all_ops = standard_frames @ as_op_frame
  if undefined === op_unpack ::
    op_unpack = bind_op_unpack(all_ops)


  const find_ops = ({has, sans}) => all_ops.filter @ op => @
       @ !has  || has .split(' ').every @ a => op.attrs.includes @ a
    && @ !sans || sans.split(' ').every @ a => ! op.attrs.includes @ a

  const basic_from_ops = find_ops @: has: 'from_route', sans: 'token msgid'
  const basic_anon_ops = find_ops @: sans: 'from_route token msgid'

  const ops_api = @{}
    from_source: _as_ops_api @ [].concat @
      basic_from_ops
      find_ops @: has: 'from_route', sans: 'msgid'

    from_reply: _as_ops_api @ [].concat @
      basic_from_ops
      find_ops @: has: 'from_route msgid'

    anon_source: _as_ops_api @ [].concat @
      basic_anon_ops
      find_ops @: sans: 'from_route msgid'

    anon_reply: _as_ops_api @ [].concat @
      basic_anon_ops
      find_ops @: has: 'msgid', sans: 'from_route'

  shared.op_unpack = op_unpack
  shared.ops_api = ops_api
